/-
File: signature_recover_public_key_compute_doubling_slope_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .signature_recover_public_key_code
import ..signature_recover_public_key_spec
import .signature_recover_public_key_verify_zero_soundness
import .signature_recover_public_key_nondet_bigint3_soundness
import .signature_recover_public_key_unreduced_mul_soundness
import .signature_recover_public_key_unreduced_sqr_soundness
open tactic

open starkware.cairo.common.cairo_secp.ec
open starkware.cairo.common.cairo_secp.bigint
open starkware.cairo.common.cairo_secp.bigint3
open starkware.cairo.common.cairo_secp.field
open starkware.cairo.common.cairo_secp.ec_point

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.cairo_secp.ec.compute_doubling_slope autogenerated soundness theorem -/

theorem auto_sound_compute_doubling_slope
    -- arguments
    (range_check_ptr : F) (point : EcPoint mem)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_compute_doubling_slope σ.pc)
    -- all dependencies are in memory
    (h_mem_4 : mem_at mem code_nondet_bigint3 (σ.pc  - 176))
    (h_mem_5 : mem_at mem code_unreduced_mul (σ.pc  - 164))
    (h_mem_6 : mem_at mem code_unreduced_sqr (σ.pc  - 144))
    (h_mem_7 : mem_at mem code_verify_zero (σ.pc  - 128))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
    (hin_point : point = cast_EcPoint mem (σ.fp - 8))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      τ.ap = σ.ap + 85 ∧
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 9)) (mem $ τ.ap - 4)
        (spec_compute_doubling_slope mem κ range_check_ptr point (mem (τ.ap - 4)) (cast_BigInt3  mem (τ.ap - 3)))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  have h_mem_rec := h_mem,
  unpack_memory code_compute_doubling_slope at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43⟩,
  -- function call
  step_assert_eq hpc0 with arg0,
  step_sub hpc1 (auto_sound_nondet_bigint3 mem _ range_check_ptr _ _),
  { rw hpc2, norm_num2, exact h_mem_4 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point] },
    try { dsimp [cast_EcPoint, cast_BigInt3] },
    try { arith_simps }, try { simp only [arg0] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call3 ap3 h_call3,
  rcases h_call3 with ⟨h_call3_ap_offset, h_call3⟩,
  rcases h_call3 with ⟨rc_m3, rc_mle3, hl_range_check_ptr₁, h_call3⟩,
  mkdef htv_range_check_ptr₁ : range_check_ptr₁ = (mem (ap3 - 4)),
  simp only [←htv_range_check_ptr₁] at h_call3,
  mkdef htv_slope : slope = (cast_BigInt3 mem (ap3 - 3)),
  simp only [←htv_slope] at h_call3,
  try { simp only [arg0] at hl_range_check_ptr₁ },
  try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₁ }, try { rw [←hin_range_check_ptr] at hl_range_check_ptr₁ },
  try { simp only [arg0] at h_call3 },
  rw [hin_range_check_ptr] at h_call3,
  clear arg0,
  -- function call
  step_assert_eq hpc3 with arg0,
  step_assert_eq hpc4 with arg1,
  step_assert_eq hpc5 with arg2,
  step_sub hpc6 (auto_sound_unreduced_sqr mem _ point.x _ _),
  { rw hpc7, norm_num2, exact h_mem_6 },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2] },
      try { simp only [h_call3_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call8 ap8 h_call8,
  rcases h_call8 with ⟨h_call8_ap_offset, h_call8⟩,
  mkdef htv_x_sqr : x_sqr = (cast_UnreducedBigInt3 mem (ap8 - 3)),
  simp only [←htv_x_sqr] at h_call8,
  clear arg0 arg1 arg2,
  -- function call
  step_assert_eq hpc8 with arg0,
  step_assert_eq hpc9 with arg1,
  step_assert_eq hpc10 with arg2,
  step_assert_eq hpc11 with arg3,
  step_assert_eq hpc12 with arg4,
  step_assert_eq hpc13 with arg5,
  step_sub hpc14 (auto_sound_unreduced_mul mem _ slope point.y _ _ _),
  { rw hpc15, norm_num2, exact h_mem_5 },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5] },
      try { simp only [h_call3_ap_offset, h_call8_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5] },
      try { simp only [h_call3_ap_offset, h_call8_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call16 ap16 h_call16,
  rcases h_call16 with ⟨h_call16_ap_offset, h_call16⟩,
  mkdef htv_slope_y : slope_y = (cast_UnreducedBigInt3 mem (ap16 - 3)),
  simp only [←htv_slope_y] at h_call16,
  clear arg0 arg1 arg2 arg3 arg4 arg5,
  -- function call
  step_assert_eq hpc16 hpc17 with arg0,
  step_assert_eq hpc18 with arg1,
  step_assert_eq hpc19 hpc20 with arg2,
  step_assert_eq hpc21 with arg3,
  step_assert_eq hpc22 hpc23 with arg4,
  step_assert_eq hpc24 with arg5,
  step_assert_eq hpc25 hpc26 with arg6,
  step_assert_eq hpc27 with arg7,
  step_assert_eq hpc28 hpc29 with arg8,
  step_assert_eq hpc30 with arg9,
  step_assert_eq hpc31 hpc32 with arg10,
  step_assert_eq hpc33 with arg11,
  step_assert_eq hpc34 with arg12,
  step_assert_eq hpc35 with arg13,
  step_assert_eq hpc36 with arg14,
  step_assert_eq hpc37 with arg15,
  step_sub hpc38 (auto_sound_verify_zero mem _ range_check_ptr₁ {
    d0 := 3 * x_sqr.d0 - 2 * slope_y.d0,
    d1 := 3 * x_sqr.d1 - 2 * slope_y.d1,
    d2 := 3 * x_sqr.d2 - 2 * slope_y.d2
  } _ _ _),
  { rw hpc39, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr, htv_slope_y] },
    try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, (eq_sub_of_eq_add arg13), (eq_sub_of_eq_add arg14), (eq_sub_of_eq_add arg15)] },
    try { simp only [h_call3_ap_offset, h_call8_ap_offset, h_call16_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr, htv_slope_y] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, (eq_sub_of_eq_add arg13), (eq_sub_of_eq_add arg14), (eq_sub_of_eq_add arg15)] },
      try { simp only [h_call3_ap_offset, h_call8_ap_offset, h_call16_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call40 ap40 h_call40,
  rcases h_call40 with ⟨h_call40_ap_offset, h_call40⟩,
  rcases h_call40 with ⟨rc_m40, rc_mle40, hl_range_check_ptr₂, h_call40⟩,
  mkdef htv_range_check_ptr₂ : range_check_ptr₂ = (mem (ap40 - 1)),
  simp only [←htv_range_check_ptr₂] at h_call40,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10 ,arg11 ,arg12 ,arg13 ,arg14 ,arg15] at hl_range_check_ptr₂ },
  try { rw [h_call16_ap_offset, h_call8_ap_offset] at hl_range_check_ptr₂ }, try { arith_simps at hl_range_check_ptr₂ },
  try { rw [←htv_range_check_ptr₂] at hl_range_check_ptr₂ }, try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₂ },
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10 ,arg11 ,arg12 ,arg13 ,arg14 ,arg15] at h_call40 },
  try { rw [h_call16_ap_offset, h_call8_ap_offset] at h_call40 }, try { arith_simps at h_call40 },
  rw [←htv_range_check_ptr₁, hl_range_check_ptr₁, hin_range_check_ptr] at h_call40,
  clear arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15,
  -- return
  step_assert_eq hpc40 with hret0,
  step_assert_eq hpc41 with hret1,
  step_assert_eq hpc42 with hret2,
  step_ret hpc43,
  -- finish
  step_done, use_only [rfl, rfl],
  split,
  { try { simp only [h_call3_ap_offset ,h_call8_ap_offset ,h_call16_ap_offset ,h_call40_ap_offset] },
    try { arith_simps }, try { refl } },
  -- range check condition
  use_only (rc_m3+rc_m40+0+0), split,
  linarith [rc_mle3, rc_mle40],
  split,
  { try { norm_num1 }, arith_simps, try { simp only [hret0 ,hret1 ,hret2] },
    try { rw [←htv_range_check_ptr₂] }, try { rw [hl_range_check_ptr₂] }, try { rw [←htv_range_check_ptr₁] }, try { rw [hl_range_check_ptr₁] }, try { rw [hin_range_check_ptr] },
    try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
  intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
  have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
  -- Final Proof
  -- user-provided reduction
  suffices auto_spec: auto_spec_compute_doubling_slope mem _ range_check_ptr point _ _,
  { apply sound_compute_doubling_slope, apply auto_spec },
  -- prove the auto generated assertion
  dsimp [auto_spec_compute_doubling_slope],
  try { norm_num1 }, try { arith_simps },
  use_only [κ_call3],
  use_only [range_check_ptr₁],
  use_only [slope],
  have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
  have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
  have spec3 := h_call3 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at spec3 }, try { rw [←htv_range_check_ptr₁] at spec3 },
  try { dsimp at spec3, arith_simps at spec3 },
  use_only [spec3],
  use_only [κ_call8],
  use_only [x_sqr],
  try { dsimp at h_call8, arith_simps at h_call8 },
  try { use_only [h_call8] },
  use_only [κ_call16],
  use_only [slope_y],
  try { dsimp at h_call16, arith_simps at h_call16 },
  try { use_only [h_call16] },
  use_only [κ_call40],
  use_only [range_check_ptr₂],
  have rc_h_range_check_ptr₂ := range_checked_offset' rc_h_range_check_ptr₁,
  have rc_h_range_check_ptr₂' := range_checked_add_right rc_h_range_check_ptr₂, try { norm_cast at rc_h_range_check_ptr₂' },
  have spec40 := h_call40 rc_h_range_check_ptr₁',
    try { rw [←hin_range_check_ptr] at spec40 }, try { rw [←hl_range_check_ptr₁] at spec40 }, try { rw [←htv_range_check_ptr₂] at spec40 },
  try { dsimp at spec40, arith_simps at spec40 },
  use_only [spec40],
  try { split, trivial <|> linarith },
  try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr, htv_slope_y, htv_range_check_ptr₂] }, },
  try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
  try { arith_simps }, try { simp only [hret0, hret1, hret2] },
  try { simp only [h_call3_ap_offset, h_call8_ap_offset, h_call16_ap_offset, h_call40_ap_offset] },
  try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
end

