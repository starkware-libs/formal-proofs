/-
File: signature_recover_public_key_call_recover_public_key_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .signature_recover_public_key_code
import ..signature_recover_public_key_spec
import .signature_recover_public_key_recover_public_key_soundness
open tactic

open starkware.cairo.common.cairo_secp.verification.signature_recover_public_key
open starkware.cairo.common.cairo_secp.bigint3
open starkware.cairo.common.cairo_secp.ec_point
open starkware.cairo.common.cairo_secp.signature
open starkware.cairo.common.cairo_secp.field
open starkware.cairo.common.math
open starkware.cairo.common.cairo_secp.ec
open starkware.cairo.common.cairo_secp.bigint

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.cairo_secp.verification.signature_recover_public_key.call_recover_public_key autogenerated soundness theorem -/

theorem auto_sound_call_recover_public_key
    -- arguments
    (range_check_ptr : F) (msg_hash r s : BigInt3 mem) (v : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_call_recover_public_key σ.pc)
    -- all dependencies are in memory
    (h_mem_0 : mem_at mem code_assert_nn (σ.pc  - 903))
    (h_mem_1 : mem_at mem code_assert_le (σ.pc  - 899))
    (h_mem_2 : mem_at mem code_assert_nn_le (σ.pc  - 894))
    (h_mem_3 : mem_at mem code_bigint_mul (σ.pc  - 885))
    (h_mem_4 : mem_at mem code_nondet_bigint3 (σ.pc  - 871))
    (h_mem_5 : mem_at mem code_unreduced_mul (σ.pc  - 859))
    (h_mem_6 : mem_at mem code_unreduced_sqr (σ.pc  - 839))
    (h_mem_7 : mem_at mem code_verify_zero (σ.pc  - 823))
    (h_mem_8 : mem_at mem code_is_zero (σ.pc  - 800))
    (h_mem_9 : mem_at mem code_reduce (σ.pc  - 764))
    (h_mem_10 : mem_at mem code_validate_reduced_field_element (σ.pc  - 751))
    (h_mem_11 : mem_at mem code_ec_negate (σ.pc  - 711))
    (h_mem_12 : mem_at mem code_compute_doubling_slope (σ.pc  - 695))
    (h_mem_13 : mem_at mem code_compute_slope (σ.pc  - 651))
    (h_mem_14 : mem_at mem code_ec_double (σ.pc  - 627))
    (h_mem_15 : mem_at mem code_fast_ec_add (σ.pc  - 554))
    (h_mem_16 : mem_at mem code_ec_add (σ.pc  - 467))
    (h_mem_17 : mem_at mem code_ec_mul_inner (σ.pc  - 411))
    (h_mem_18 : mem_at mem code_ec_mul (σ.pc  - 310))
    (h_mem_19 : mem_at mem code_get_generator_point (σ.pc  - 230))
    (h_mem_20 : mem_at mem code_div_mod_n (σ.pc  - 217))
    (h_mem_21 : mem_at mem code_get_point_from_x (σ.pc  - 152))
    (h_mem_22 : mem_at mem code_recover_public_key (σ.pc  - 86))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 13))
    (hin_msg_hash : msg_hash = cast_BigInt3 mem (σ.fp - 12))
    (hin_r : r = cast_BigInt3 mem (σ.fp - 9))
    (hin_s : s = cast_BigInt3 mem (σ.fp - 6))
    (hin_v : v = mem (σ.fp - 3))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 13)) (mem $ τ.ap - 7)
        (spec_call_recover_public_key mem κ range_check_ptr msg_hash r s v (mem (τ.ap - 7)) (cast_EcPoint  mem (τ.ap - 6)))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  have h_mem_rec := h_mem,
  unpack_memory code_call_recover_public_key at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13⟩,
  -- tail function call
  step_assert_eq hpc0 with arg0,
  step_assert_eq hpc1 with arg1,
  step_assert_eq hpc2 with arg2,
  step_assert_eq hpc3 with arg3,
  step_assert_eq hpc4 with arg4,
  step_assert_eq hpc5 with arg5,
  step_assert_eq hpc6 with arg6,
  step_assert_eq hpc7 with arg7,
  step_assert_eq hpc8 with arg8,
  step_assert_eq hpc9 with arg9,
  step_assert_eq hpc10 with arg10,
  step_sub hpc11 (auto_sound_recover_public_key mem _ range_check_ptr msg_hash r s v _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _),
  { rw hpc12, norm_num2, exact h_mem_22 },
  { rw hpc12, norm_num2, exact h_mem_0 },
  { rw hpc12, norm_num2, exact h_mem_1 },
  { rw hpc12, norm_num2, exact h_mem_2 },
  { rw hpc12, norm_num2, exact h_mem_3 },
  { rw hpc12, norm_num2, exact h_mem_4 },
  { rw hpc12, norm_num2, exact h_mem_5 },
  { rw hpc12, norm_num2, exact h_mem_6 },
  { rw hpc12, norm_num2, exact h_mem_7 },
  { rw hpc12, norm_num2, exact h_mem_8 },
  { rw hpc12, norm_num2, exact h_mem_9 },
  { rw hpc12, norm_num2, exact h_mem_10 },
  { rw hpc12, norm_num2, exact h_mem_11 },
  { rw hpc12, norm_num2, exact h_mem_12 },
  { rw hpc12, norm_num2, exact h_mem_13 },
  { rw hpc12, norm_num2, exact h_mem_14 },
  { rw hpc12, norm_num2, exact h_mem_15 },
  { rw hpc12, norm_num2, exact h_mem_16 },
  { rw hpc12, norm_num2, exact h_mem_17 },
  { rw hpc12, norm_num2, exact h_mem_18 },
  { rw hpc12, norm_num2, exact h_mem_19 },
  { rw hpc12, norm_num2, exact h_mem_20 },
  { rw hpc12, norm_num2, exact h_mem_21 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_msg_hash, hin_r, hin_s, hin_v] },
    try { dsimp [cast_BigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_msg_hash, hin_r, hin_s, hin_v] },
      try { dsimp [cast_BigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_msg_hash, hin_r, hin_s, hin_v] },
      try { dsimp [cast_BigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_msg_hash, hin_r, hin_s, hin_v] },
      try { dsimp [cast_BigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_msg_hash, hin_r, hin_s, hin_v] },
    try { dsimp [cast_BigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call13 ap13 h_call13,
  rcases h_call13 with ⟨rc_m13, rc_mle13, hl_range_check_ptr₁, h_call13⟩,
  step_ret hpc13,
  mkdef htv_range_check_ptr₁ : range_check_ptr₁ = (mem (ap13 - 7)),
  simp only [←htv_range_check_ptr₁] at h_call13,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10] at hl_range_check_ptr₁ },
  try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₁ }, try { rw [←hin_range_check_ptr] at hl_range_check_ptr₁ },
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10] at h_call13 },
  rw [hin_range_check_ptr] at h_call13,
  clear arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10,
  -- finish
  step_done, use_only [rfl, rfl],
  -- range check condition
  use_only (rc_m13+0+0), split,
  linarith [rc_mle13],
  split,
  { try { norm_num1 }, arith_simps,
    try { rw [←htv_range_check_ptr₁] }, try { rw [hl_range_check_ptr₁] }, try { rw [hin_range_check_ptr] },
    try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
  intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
  have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
  -- Final Proof
  -- user-provided reduction
  suffices auto_spec: auto_spec_call_recover_public_key mem _ range_check_ptr msg_hash r s v _ _,
  { apply sound_call_recover_public_key, apply auto_spec },
  -- prove the auto generated assertion
  dsimp [auto_spec_call_recover_public_key],
  try { norm_num1 }, try { arith_simps },
  use_only [κ_call13],
  have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
  have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
  have spec13 := h_call13 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at spec13 },
  try { dsimp at spec13, arith_simps at spec13 },
  use_only [spec13],
  try { linarith },
end

