/-
File: squash_dict_assert_le_felt_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .squash_dict_code
import ..squash_dict_spec
open tactic

open starkware.cairo.common.math

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.math.assert_le_felt autogenerated soundness theorem -/

theorem auto_sound_assert_le_felt
    -- arguments
    (range_check_ptr a b : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_assert_le_felt σ.pc)
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 5))
    (hin_a : a = mem (σ.fp - 4))
    (hin_b : b = mem (σ.fp - 3))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      τ.ap = σ.ap + 15 ∧
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 5)) (mem $ τ.ap - 1)
        (spec_assert_le_felt mem κ range_check_ptr a b (mem (τ.ap - 1)))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  have h_mem_rec := h_mem,
  unpack_memory code_assert_le_felt at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44⟩,
  -- const
  mkdef hc_PRIME_OVER_3_HIGH : PRIME_OVER_3_HIGH = (3544607988759775765608368578435044694 : F),
  -- const
  mkdef hc_PRIME_OVER_2_HIGH : PRIME_OVER_2_HIGH = (5316911983139663648412552867652567041 : F),
  -- tempvar
  step_assert_eq hpc0 with tv_arc_short0,
  step_assert_eq hpc1 with tv_arc_short1,
  step_assert_eq hpc2 hpc3 with tv_arc_short2,
  step_assert_eq hpc4 with tv_arc_short3,
  mkdef hl_arc_short : arc_short = (mem range_check_ptr + mem (range_check_ptr + 1) * PRIME_OVER_3_HIGH : F),
  have htv_arc_short: arc_short = _, {
    apply eq.symm, apply eq.trans tv_arc_short3,
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short] },
      try { arith_simps }, try { simp only [tv_arc_short0, tv_arc_short1, tv_arc_short2] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_arc_short0 tv_arc_short1 tv_arc_short2 tv_arc_short3,
  try { dsimp at hl_arc_short }, try { arith_simps at hl_arc_short },
  -- tempvar
  step_assert_eq hpc5 with tv_arc_long0,
  step_assert_eq hpc6 with tv_arc_long1,
  step_assert_eq hpc7 hpc8 with tv_arc_long2,
  step_assert_eq hpc9 with tv_arc_long3,
  mkdef hl_arc_long : arc_long = (mem (range_check_ptr + 2) + mem (range_check_ptr + 3) * PRIME_OVER_2_HIGH : F),
  have htv_arc_long: arc_long = _, {
    apply eq.symm, apply eq.trans tv_arc_long3,
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long] },
      try { arith_simps }, try { simp only [tv_arc_long0, tv_arc_long1, tv_arc_long2] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_arc_long0 tv_arc_long1 tv_arc_long2 tv_arc_long3,
  try { dsimp at hl_arc_long }, try { arith_simps at hl_arc_long },
  -- let
  mkdef hl_range_check_ptr₁ : range_check_ptr₁ = (range_check_ptr + 4 : F),
  try { dsimp at hl_range_check_ptr₁ }, try { arith_simps at hl_range_check_ptr₁ },
  -- let
  mkdef hl_arc_sum : arc_sum = (arc_short + arc_long : F),
  try { dsimp at hl_arc_sum }, try { arith_simps at hl_arc_sum },
  -- let
  mkdef hl_arc_prod : arc_prod = (arc_short * arc_long : F),
  try { dsimp at hl_arc_prod }, try { arith_simps at hl_arc_prod },
  -- jnz
  apply of_register_state,
  intros regstate10 regstate10eq,
  have regstateapeq_a10 := congr_arg register_state.ap regstate10eq,
  try { dsimp at regstateapeq_a10 },
  step_jnz hpc10 hpc11 with a10 a10,
  {
    -- jnz: positive branch
    rw ←regstateapeq_a10 at a10,
    -- compound assert eq
    step_assert_eq hpc12 hpc13 with temp0,
    step_assert_eq hpc14 with temp1,
    step_assert_eq hpc15 with temp2,
    have a12: arc_sum = ((-1)) - a, {
      apply assert_eq_reduction temp2.symm,
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod] },
      try { arith_simps }, try { simp only [temp0, (eq_sub_of_eq_add temp1)] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a12 }, try { arith_simps at a12 },
    clear temp0 temp1 temp2,
    -- compound assert eq
    step_assert_eq hpc16 with temp0,
    step_assert_eq hpc17 hpc18 with temp1,
    step_assert_eq hpc19 with temp2,
    step_assert_eq hpc20 with temp3,
    have a16: arc_prod = (a - b) * (1 + b), {
      try { simp only [add_comm 1 b] },
      apply assert_eq_reduction temp3.symm,
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod] },
      try { arith_simps }, try { simp only [(eq_sub_of_eq_add temp0), temp1, temp2] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a16 }, try { arith_simps at a16 },
    clear temp0 temp1 temp2 temp3,
    -- return
    step_assert_eq hpc21 hpc22 with hret0,
    step_ret hpc23,
    -- finish
    step_done, use_only [rfl, rfl],
    split, refl,
    -- range check condition
    use_only (4+0+0), split,
    linarith [],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hret0] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
    have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
    -- Final Proof
    -- user-provided reduction
    suffices auto_spec: auto_spec_assert_le_felt mem _ range_check_ptr a b _,
    { apply sound_assert_le_felt, apply auto_spec },
    -- prove the auto generated assertion
    dsimp [auto_spec_assert_le_felt],
    try { norm_num1 }, try { arith_simps },
    use [PRIME_OVER_3_HIGH, hc_PRIME_OVER_3_HIGH],
    use [PRIME_OVER_2_HIGH, hc_PRIME_OVER_2_HIGH],
    use_only [arc_short, hl_arc_short],
    try { dsimp }, try { arith_simps },
    cases rc_h_range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
    cases rc_h_range_check_ptr' (1) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
    use_only [arc_long, hl_arc_long],
    try { dsimp }, try { arith_simps },
    cases rc_h_range_check_ptr' (2) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
    cases rc_h_range_check_ptr' (3) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
    have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
    have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁,
      try { norm_cast at rc_h_range_check_ptr₁' }, try { rw [add_zero] at rc_h_range_check_ptr₁' },
    use_only [range_check_ptr₁, hl_range_check_ptr₁],
    try { dsimp }, try { arith_simps },
    use_only [arc_sum, hl_arc_sum],
    try { dsimp }, try { arith_simps },
    use_only [arc_prod, hl_arc_prod],
    try { dsimp }, try { arith_simps },
    use_only (mem regstate10.ap),
    left,
    use_only [a10],
    use_only [a12],
    use_only [a16],
    try { split, trivial <|> linarith },
    try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod] }, },
    try { arith_simps }, try { simp only [hret0] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  {
    -- jnz: negative branch
    rw ←regstateapeq_a10 at a10,
    -- jnz
    apply of_register_state,
    intros regstate24 regstate24eq,
    have regstateapeq_a24 := congr_arg register_state.ap regstate24eq,
    try { dsimp at regstateapeq_a24 },
    step_jnz hpc24 hpc25 with a24 a24,
    {
      -- jnz: positive branch
      rw ←regstateapeq_a24 at a24,
      -- tempvar
      step_assert_eq hpc26 hpc27 with tv_m1mb0,
      step_assert_eq hpc28 with tv_m1mb1,
      mkdef hl_m1mb : m1mb = (((-1)) - b : F),
      have htv_m1mb: m1mb = _, {
        apply eq.symm, apply eq.trans (eq_sub_of_eq_add tv_m1mb1),
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod, hl_m1mb] },
          try { arith_simps }, try { simp only [tv_m1mb0] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_m1mb0 tv_m1mb1,
      try { dsimp at hl_m1mb }, try { arith_simps at hl_m1mb },
      -- compound assert eq
      step_assert_eq hpc29 with temp0,
      step_assert_eq hpc30 with temp1,
      have a29: arc_sum = a + m1mb, {
        apply assert_eq_reduction temp1.symm,
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod, hl_m1mb, htv_m1mb] },
        try { arith_simps }, try { simp only [temp0] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a29 }, try { arith_simps at a29 },
      clear temp0 temp1,
      -- compound assert eq
      step_assert_eq hpc31 with temp0,
      step_assert_eq hpc32 with temp1,
      have a31: arc_prod = a * m1mb, {
        apply assert_eq_reduction temp1.symm,
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod, hl_m1mb, htv_m1mb] },
        try { arith_simps }, try { simp only [temp0] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a31 }, try { arith_simps at a31 },
      clear temp0 temp1,
      -- return
      step_assert_eq hpc33 hpc34 with hret0,
      step_ret hpc35,
      -- finish
      step_done, use_only [rfl, rfl],
      split, refl,
      -- range check condition
      use_only (4+0+0), split,
      linarith [],
      split,
      { try { norm_num1 }, arith_simps, try { simp only [hret0] },
        try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
      intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
      have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
      -- Final Proof
      -- user-provided reduction
      suffices auto_spec: auto_spec_assert_le_felt mem _ range_check_ptr a b _,
      { apply sound_assert_le_felt, apply auto_spec },
      -- prove the auto generated assertion
      dsimp [auto_spec_assert_le_felt],
      try { norm_num1 }, try { arith_simps },
      use [PRIME_OVER_3_HIGH, hc_PRIME_OVER_3_HIGH],
      use [PRIME_OVER_2_HIGH, hc_PRIME_OVER_2_HIGH],
      use_only [arc_short, hl_arc_short],
      try { dsimp }, try { arith_simps },
      cases rc_h_range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      cases rc_h_range_check_ptr' (1) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      use_only [arc_long, hl_arc_long],
      try { dsimp }, try { arith_simps },
      cases rc_h_range_check_ptr' (2) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      cases rc_h_range_check_ptr' (3) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
      have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁,
        try { norm_cast at rc_h_range_check_ptr₁' }, try { rw [add_zero] at rc_h_range_check_ptr₁' },
      use_only [range_check_ptr₁, hl_range_check_ptr₁],
      try { dsimp }, try { arith_simps },
      use_only [arc_sum, hl_arc_sum],
      try { dsimp }, try { arith_simps },
      use_only [arc_prod, hl_arc_prod],
      try { dsimp }, try { arith_simps },
      use_only (mem regstate10.ap),
      right,
      use_only [a10],
      use_only (mem regstate24.ap),
      left,
      use_only [a24],
      use_only [m1mb, hl_m1mb],
      try { dsimp }, try { arith_simps },
      use_only [a29],
      use_only [a31],
      try { split, trivial <|> linarith },
      try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod, hl_m1mb, htv_m1mb] }, },
      try { arith_simps }, try { simp only [hret0] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    {
      -- jnz: negative branch
      rw ←regstateapeq_a24 at a24,
      -- compound assert eq
      step_assert_eq hpc36 with temp0,
      have a36: arc_sum = b, {
        apply assert_eq_reduction temp0.symm,
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a36 }, try { arith_simps at a36 },
      clear temp0,
      -- compound assert eq
      step_assert_eq hpc37 with temp0,
      step_assert_eq hpc38 with temp1,
      step_assert_eq hpc39 with temp2,
      have a37: arc_prod = a * (b - a), {
        apply assert_eq_reduction temp2.symm,
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod] },
        try { arith_simps }, try { simp only [(eq_sub_of_eq_add temp0), temp1] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a37 }, try { arith_simps at a37 },
      clear temp0 temp1 temp2,
      -- ap += 2
      step_advance_ap hpc40 hpc41,
      -- return
      step_assert_eq hpc42 hpc43 with hret0,
      step_ret hpc44,
      -- finish
      step_done, use_only [rfl, rfl],
      split, refl,
      -- range check condition
      use_only (4+0+0), split,
      linarith [],
      split,
      { try { norm_num1 }, arith_simps, try { simp only [hret0] },
        try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
      intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
      have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
      -- Final Proof
      -- user-provided reduction
      suffices auto_spec: auto_spec_assert_le_felt mem _ range_check_ptr a b _,
      { apply sound_assert_le_felt, apply auto_spec },
      -- prove the auto generated assertion
      dsimp [auto_spec_assert_le_felt],
      try { norm_num1 }, try { arith_simps },
      use [PRIME_OVER_3_HIGH, hc_PRIME_OVER_3_HIGH],
      use [PRIME_OVER_2_HIGH, hc_PRIME_OVER_2_HIGH],
      use_only [arc_short, hl_arc_short],
      try { dsimp }, try { arith_simps },
      cases rc_h_range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      cases rc_h_range_check_ptr' (1) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      use_only [arc_long, hl_arc_long],
      try { dsimp }, try { arith_simps },
      cases rc_h_range_check_ptr' (2) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      cases rc_h_range_check_ptr' (3) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [hin_range_check_ptr], arith_simps, exact hn },
      have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
      have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁,
        try { norm_cast at rc_h_range_check_ptr₁' }, try { rw [add_zero] at rc_h_range_check_ptr₁' },
      use_only [range_check_ptr₁, hl_range_check_ptr₁],
      try { dsimp }, try { arith_simps },
      use_only [arc_sum, hl_arc_sum],
      try { dsimp }, try { arith_simps },
      use_only [arc_prod, hl_arc_prod],
      try { dsimp }, try { arith_simps },
      use_only (mem regstate10.ap),
      right,
      use_only [a10],
      use_only (mem regstate24.ap),
      right,
      use_only [a24],
      use_only [a36],
      use_only [a37],
      try { split, trivial <|> linarith },
      try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, hc_PRIME_OVER_3_HIGH, hc_PRIME_OVER_2_HIGH, hl_arc_short, htv_arc_short, hl_arc_long, htv_arc_long, hl_range_check_ptr₁, hl_arc_sum, hl_arc_prod] }, },
      try { arith_simps }, try { simp only [hret0] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    }
  }
end

