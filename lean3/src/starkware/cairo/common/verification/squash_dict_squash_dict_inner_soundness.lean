/-
File: squash_dict_squash_dict_inner_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .squash_dict_code
import ..squash_dict_spec
import .squash_dict_assert_lt_felt_soundness
open tactic

open starkware.cairo.common.squash_dict
open starkware.cairo.common.math
open starkware.cairo.common.dict_access

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.squash_dict.squash_dict_inner autogenerated soundness theorem -/

theorem auto_sound_squash_dict_inner_block54
    -- An independent ap variable.
    (ap : F)
    -- arguments
    (range_check_ptr : F) (dict_accesses : π_DictAccess mem) (dict_accesses_end_minus1 key remaining_accesses : F) (squashed_dict : π_DictAccess mem) (big_keys : F) (dict_diff : π_DictAccess mem) (first_value should_skip_loop next_key : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_squash_dict_inner σ.pc)
    -- all dependencies are in memory
    (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 84))
    (h_mem_1 : mem_at mem code_assert_lt_felt (σ.pc  - 39))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (ap - 5))
    (hin_dict_accesses : dict_accesses = cast_π_DictAccess mem (mem (ap - 4)))
    (hin_dict_accesses_end_minus1 : dict_accesses_end_minus1 = mem (ap - 3))
    (hin_key : key = mem (σ.fp - 6))
    (hin_remaining_accesses : remaining_accesses = mem (ap - 1))
    (hin_squashed_dict : squashed_dict = cast_π_DictAccess mem (mem (σ.fp - 4)))
    (hin_big_keys : big_keys = mem (σ.fp - 3))
    (hin_dict_diff : dict_diff = cast_π_DictAccess mem (mem (σ.fp - 4)))
    (hin_first_value : first_value = mem σ.fp)
    (hin_should_skip_loop : should_skip_loop = mem (σ.fp + 1))
    (hin_next_key : next_key = mem (ap - 2))
    (νbound : ℕ)
    (νih : ∀ (σ : register_state F)
             (range_check_ptr : F) (dict_accesses : π_DictAccess mem) (dict_accesses_end_minus1 key remaining_accesses : F) (squashed_dict : π_DictAccess mem) (big_keys : F)
             (h_mem : mem_at mem code_squash_dict_inner σ.pc)
             (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 84))
             (h_mem_1 : mem_at mem code_assert_lt_felt (σ.pc  - 39))
             (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
             (hin_dict_accesses : dict_accesses = cast_π_DictAccess mem (mem (σ.fp - 8)))
             (hin_dict_accesses_end_minus1 : dict_accesses_end_minus1 = mem (σ.fp - 7))
             (hin_key : key = mem (σ.fp - 6))
             (hin_remaining_accesses : remaining_accesses = mem (σ.fp - 5))
             (hin_squashed_dict : squashed_dict = cast_π_DictAccess mem (mem (σ.fp - 4)))
             (hin_big_keys : big_keys = mem (σ.fp - 3)),
             ensuresb_ret νbound mem σ (λ κ τ,
               ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 9)) (mem $ τ.ap - 2)
                 (spec_squash_dict_inner mem κ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys (mem (τ.ap - 2)) (cast_π_DictAccess  mem (mem (τ.ap - 1))))))
    -- conclusion
  : ensuresb_ret νbound mem
    {pc := σ.pc + 66, ap := ap, fp := σ.fp}
    (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (ap - 5)) (mem $ τ.ap - 2)
        (auto_spec_squash_dict_inner_block54 mem κ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop next_key (mem (τ.ap - 2)) (cast_π_DictAccess  mem (mem (τ.ap - 1))))) :=
begin
  have h_mem_rec := h_mem,
  unpack_memory code_squash_dict_inner at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45, hpc46, hpc47, hpc48, hpc49, hpc50, hpc51, hpc52, hpc53, hpc54, hpc55, hpc56, hpc57, hpc58, hpc59, hpc60, hpc61, hpc62, hpc63, hpc64, hpc65, hpc66, hpc67, hpc68, hpc69, hpc70, hpc71⟩,
  -- tail recursive function call
  step_assert_eq hpc66 hpc67 with arg0,
  step_assert_eq hpc68 with arg1,
  step_rec_sub hpc69 (νih _ range_check_ptr dict_accesses dict_accesses_end_minus1 next_key remaining_accesses (cast_π_DictAccess mem (squashed_dict + DictAccess.SIZE)) big_keys _ _ _ _ _ _ _ _ _ _),
  { rw hpc70, norm_num, exact h_mem_rec },
  { rw hpc70, norm_num2, exact h_mem_0 },
  { rw hpc70, norm_num2, exact h_mem_1 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hin_next_key] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
    try { dsimp [cast_π_DictAccess] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hin_next_key] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
      try { dsimp [cast_π_DictAccess] },
      try { arith_simps }, try { simp only [arg0, arg1] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hin_next_key] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
    try { dsimp [cast_π_DictAccess] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hin_next_key] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
    try { dsimp [cast_π_DictAccess] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hin_next_key] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
    try { dsimp [cast_π_DictAccess] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hin_next_key] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
      try { dsimp [cast_π_DictAccess] },
      try { arith_simps }, try { simp only [arg0, arg1] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hin_next_key] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
    try { dsimp [cast_π_DictAccess] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call71 ap71 h_call71,
  rcases h_call71 with ⟨rc_m71, rc_mle71, hl_range_check_ptr₁, h_call71⟩,
  step_ret hpc71,
  mkdef htv_range_check_ptr₁ : range_check_ptr₁ = (mem (ap71 - 2)),
  simp only [←htv_range_check_ptr₁] at h_call71,
  try { simp only [arg0 ,arg1] at hl_range_check_ptr₁ },
  try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₁ }, try { rw [←hin_range_check_ptr] at hl_range_check_ptr₁ },
  try { simp only [arg0 ,arg1] at h_call71 },
  rw [hin_range_check_ptr] at h_call71,
  clear arg0 arg1,
  -- finish
  step_done, use_only [rfl, rfl],
  -- range check condition
  use_only (rc_m71+0+0), split,
  linarith [rc_mle71],
  split,
  { try { norm_num1 }, arith_simps,
    try { rw [←htv_range_check_ptr₁] }, try { rw [hl_range_check_ptr₁] }, try { rw [hin_range_check_ptr] },
    try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
  intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
  have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
  -- Final Proof
  dsimp [auto_spec_squash_dict_inner_block54],
  try { norm_num1 }, try { arith_simps },
  use_only [κ_call71],
  have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
  have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
  have spec71 := h_call71 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at spec71 },
  try { dsimp at spec71, arith_simps at spec71 },
  use_only [spec71],
  try { linarith },
end

theorem auto_sound_squash_dict_inner_block30
    -- An independent ap variable.
    (ap : F)
    -- arguments
    (range_check_ptr : F) (dict_accesses : π_DictAccess mem) (dict_accesses_end_minus1 key remaining_accesses : F) (squashed_dict : π_DictAccess mem) (big_keys : F) (dict_diff : π_DictAccess mem) (first_value should_skip_loop : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_squash_dict_inner σ.pc)
    -- all dependencies are in memory
    (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 84))
    (h_mem_1 : mem_at mem code_assert_lt_felt (σ.pc  - 39))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
    (hin_dict_accesses : dict_accesses = cast_π_DictAccess mem (mem (σ.fp - 8)))
    (hin_dict_accesses_end_minus1 : dict_accesses_end_minus1 = mem (σ.fp - 7))
    (hin_key : key = mem (σ.fp - 6))
    (hin_remaining_accesses : remaining_accesses = mem (σ.fp - 5))
    (hin_squashed_dict : squashed_dict = cast_π_DictAccess mem (mem (σ.fp - 4)))
    (hin_big_keys : big_keys = mem (σ.fp - 3))
    (hin_dict_diff : dict_diff = cast_π_DictAccess mem (mem (σ.fp - 4)))
    (hin_first_value : first_value = mem σ.fp)
    (hin_should_skip_loop : should_skip_loop = mem (σ.fp + 1))
    (νbound : ℕ)
    (νih : ∀ (σ : register_state F)
             (range_check_ptr : F) (dict_accesses : π_DictAccess mem) (dict_accesses_end_minus1 key remaining_accesses : F) (squashed_dict : π_DictAccess mem) (big_keys : F)
             (h_mem : mem_at mem code_squash_dict_inner σ.pc)
             (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 84))
             (h_mem_1 : mem_at mem code_assert_lt_felt (σ.pc  - 39))
             (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
             (hin_dict_accesses : dict_accesses = cast_π_DictAccess mem (mem (σ.fp - 8)))
             (hin_dict_accesses_end_minus1 : dict_accesses_end_minus1 = mem (σ.fp - 7))
             (hin_key : key = mem (σ.fp - 6))
             (hin_remaining_accesses : remaining_accesses = mem (σ.fp - 5))
             (hin_squashed_dict : squashed_dict = cast_π_DictAccess mem (mem (σ.fp - 4)))
             (hin_big_keys : big_keys = mem (σ.fp - 3)),
             ensuresb_ret νbound mem σ (λ κ τ,
               ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 9)) (mem $ τ.ap - 2)
                 (spec_squash_dict_inner mem κ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys (mem (τ.ap - 2)) (cast_π_DictAccess  mem (mem (τ.ap - 1))))))
    -- conclusion
  : ensuresb_ret νbound mem
    {pc := σ.pc + 28, ap := ap, fp := σ.fp}
    (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (ap - 1)) (mem $ τ.ap - 2)
        (auto_spec_squash_dict_inner_block30 mem κ ap range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop (mem (τ.ap - 2)) (cast_π_DictAccess  mem (mem (τ.ap - 1))))) :=
begin
  have h_mem_rec := h_mem,
  unpack_memory code_squash_dict_inner at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45, hpc46, hpc47, hpc48, hpc49, hpc50, hpc51, hpc52, hpc53, hpc54, hpc55, hpc56, hpc57, hpc58, hpc59, hpc60, hpc61, hpc62, hpc63, hpc64, hpc65, hpc66, hpc67, hpc68, hpc69, hpc70, hpc71⟩,
  -- let
  set! last_loop_locals := (squash_dict_inner.cast_π_LoopLocals mem (ap - squash_dict_inner.LoopLocals.SIZE) : squash_dict_inner.π_LoopLocals mem) with hl_last_loop_locals,
  try { dsimp at hl_last_loop_locals }, try { arith_simps at hl_last_loop_locals },
  -- assert eq
  step_assert_eq hpc28 with temp0,
  have a28: mem ap = dict_accesses_end_minus1 - last_loop_locals.access_ptr, {
    apply assert_eq_reduction (eq_sub_of_eq_add temp0),
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a28 }, try { arith_simps at a28 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc29 with temp0,
  have a29: mem ap = mem last_loop_locals.range_check_ptr, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a29 }, try { arith_simps at a29 },
  clear temp0,
  -- tempvar
  step_assert_eq hpc30 with tv_n_used_accesses0,
  mkdef hl_n_used_accesses : n_used_accesses = (last_loop_locals.range_check_ptr - range_check_ptr : F),
  have htv_n_used_accesses: n_used_accesses = _, {
    apply eq.symm, apply eq.trans (eq_sub_of_eq_add tv_n_used_accesses0),
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_n_used_accesses0,
  try { dsimp at hl_n_used_accesses }, try { arith_simps at hl_n_used_accesses },
  -- assert eq
  step_assert_eq hpc31 with temp0,
  have a31: last_loop_locals.value = dict_diff.new_value, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a31 }, try { arith_simps at a31 },
  clear temp0,
  -- let
  mkdef hl_range_check_ptr₁ : range_check_ptr₁ = (last_loop_locals.range_check_ptr + 1 : F),
  try { dsimp at hl_range_check_ptr₁ }, try { arith_simps at hl_range_check_ptr₁ },
  -- tempvar
  step_assert_eq hpc32 with tv_remaining_accesses0,
  mkdef hl_remaining_accesses₁ : remaining_accesses₁ = (remaining_accesses - n_used_accesses : F),
  have htv_remaining_accesses₁: remaining_accesses₁ = _, {
    apply eq.symm, apply eq.trans (eq_sub_of_eq_add tv_remaining_accesses0),
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_remaining_accesses0,
  try { dsimp at hl_remaining_accesses₁ }, try { arith_simps at hl_remaining_accesses₁ },
  -- if statement
  step_jnz hpc33 hpc34 with hcond hcond,
  {
    -- if: positive branch
    have a33 : remaining_accesses₁ = 0, {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a33 }, try { arith_simps at a33 },
    clear hcond,
    -- return
    step_assert_eq hpc35 hpc36 with hret0,
    step_assert_eq hpc37 hpc38 with hret1,
    step_ret hpc39,
    -- finish
    step_done, use_only [rfl, rfl],
    -- range check condition
    use_only (1+0+0), split,
    linarith [],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hret0 ,hret1] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_loop_locals.range_check_ptr, repeat { rw [add_assoc] at rc_h_loop_locals.range_check_ptr },
    have rc_h_loop_locals.range_check_ptr' := range_checked_add_right rc_h_loop_locals.range_check_ptr,
    -- Final Proof
    dsimp [auto_spec_squash_dict_inner_block30],
    try { norm_num1 }, try { arith_simps },
    use_only [last_loop_locals, hl_last_loop_locals],
    try { dsimp }, try { arith_simps },
    use_only [a28],
    use_only [a29],
    cases rc_h_loop_locals.range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [a29], arith_simps, exact hn },
    use_only [n_used_accesses, hl_n_used_accesses],
    try { dsimp }, try { arith_simps },
    use_only [a31],
    have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_loop_locals.range_check_ptr,
    have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁,
      try { norm_cast at rc_h_range_check_ptr₁' }, try { rw [add_zero] at rc_h_range_check_ptr₁' },
    use_only [range_check_ptr₁, hl_range_check_ptr₁],
    try { dsimp }, try { arith_simps },
    use_only [remaining_accesses₁, hl_remaining_accesses₁],
    try { dsimp }, try { arith_simps },
    left,
    use_only [a33],
    try { split, trivial <|> linarith },
    try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁] }, },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps }, try { simp only [hret0, hret1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  {
    -- if: negative branch
    have a33 : remaining_accesses₁ ≠ 0, {
      try { simp only [ne.def] },
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a33 }, try { arith_simps at a33 },
    clear hcond,
    -- let (ap reference)
    apply of_register_state,
    intros regstate_next_key regstateeq_next_key,
    mkdef  hl_next_key : next_key = mem regstate_next_key.ap,
    rw [regstateeq_next_key] at hl_next_key, try { dsimp at hl_next_key },
    -- ap += 1
    step_advance_ap hpc40 hpc41,
    -- if statement
    step_jnz hpc42 hpc43 with hcond hcond,
    {
      -- if: positive branch
      have a42 : big_keys = 0, {
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps }, try { simp only [hcond] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a42 }, try { arith_simps at a42 },
      clear hcond,
      -- compound assert eq
      step_assert_eq hpc44 hpc45 with temp0,
      step_assert_eq hpc46 with temp1,
      step_assert_eq hpc47 with temp2,
      have a44: mem range_check_ptr₁ = next_key - (key + 1), {
        apply assert_eq_reduction temp2.symm,
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps }, try { simp only [temp0, (eq_sub_of_eq_add temp1)] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a44 }, try { arith_simps at a44 },
      clear temp0 temp1 temp2,
      -- tempvar
      step_assert_eq hpc48 hpc49 with tv_range_check_ptr0,
      mkdef hl_range_check_ptr₂ : range_check_ptr₂ = (range_check_ptr₁ + 1 : F),
      have htv_range_check_ptr₂: range_check_ptr₂ = _, {
        apply eq.symm, apply eq.trans tv_range_check_ptr0,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_range_check_ptr0,
      try { dsimp at hl_range_check_ptr₂ }, try { arith_simps at hl_range_check_ptr₂ },
      -- tempvar
      step_assert_eq hpc50 with tv_dict_accesses0,
      set! dict_accesses₁ := (dict_accesses : π_DictAccess mem) with hl_dict_accesses₁,
      have htv_dict_accesses₁: dict_accesses₁ = cast_π_DictAccess mem (mem _), {
        try { simp only [eq_DictAccess_π_ptr_cast ] },
        apply eq.symm, apply eq.trans tv_dict_accesses0,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_dict_accesses0,
      try { dsimp at hl_dict_accesses₁ }, try { arith_simps at hl_dict_accesses₁ },
      -- tempvar
      step_assert_eq hpc51 with tv_dict_accesses_end_minus10,
      set! dict_accesses_end_minus1₁ := (dict_accesses_end_minus1 : F) with hl_dict_accesses_end_minus1₁,
      have htv_dict_accesses_end_minus1₁: dict_accesses_end_minus1₁ = _, {
        apply eq.symm, apply eq.trans tv_dict_accesses_end_minus10,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_dict_accesses_end_minus10,
      try { dsimp at hl_dict_accesses_end_minus1₁ }, try { arith_simps at hl_dict_accesses_end_minus1₁ },
      -- tempvar
      step_assert_eq hpc52 with tv_next_key0,
      mkdef hl_next_key₁ : next_key₁ = (next_key : F),
      have htv_next_key₁: next_key₁ = _, {
        apply eq.symm, apply eq.trans tv_next_key0,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_next_key0,
      try { dsimp at hl_next_key₁ }, try { arith_simps at hl_next_key₁ },
      -- tempvar
      step_assert_eq hpc53 with tv_remaining_accesses0,
      mkdef hl_remaining_accesses₂ : remaining_accesses₂ = (remaining_accesses₁ : F),
      have htv_remaining_accesses₂: remaining_accesses₂ = _, {
        apply eq.symm, apply eq.trans tv_remaining_accesses0,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_remaining_accesses0,
      try { dsimp at hl_remaining_accesses₂ }, try { arith_simps at hl_remaining_accesses₂ },
      -- jump statement
      step_jump_imm hpc54 hpc55,
      -- Use the block soundness theorem.
      apply ensuresb_ret_trans (auto_sound_squash_dict_inner_block54 mem σ _ range_check_ptr₂ dict_accesses₁ dict_accesses_end_minus1₁ key remaining_accesses₂ squashed_dict big_keys dict_diff first_value should_skip_loop next_key₁ h_mem_rec h_mem_0 h_mem_1 _ _ _ hin_key _ hin_squashed_dict hin_big_keys hin_dict_diff hin_first_value hin_should_skip_loop _ νbound νih),
      rotate,
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, hl_range_check_ptr₂, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      intros κ_block54 τ, try { arith_simps },
      intro h_block54,
      rcases h_block54 with ⟨rc_m_block54, rc_m_le_block54, hblk_range_check_ptr₃, h_block54⟩,
        try { rw [←htv_range_check_ptr₂] at h_block54 }, try { rw [hl_range_check_ptr₂] at h_block54 }, try { rw [hl_range_check_ptr₁] at h_block54 },
      -- range check condition
      use_only (1+1+rc_m_block54+0+0), split,
      linarith [rc_m_le_block54],
      split,
      { try { norm_num1 }, arith_simps, try { simp only [hblk_range_check_ptr₃] },
        try { rw [←htv_range_check_ptr₂] }, try { rw [hl_range_check_ptr₂] }, try { rw [hl_range_check_ptr₁] },
        try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
      intro rc_h_loop_locals.range_check_ptr, repeat { rw [add_assoc] at rc_h_loop_locals.range_check_ptr },
      have rc_h_loop_locals.range_check_ptr' := range_checked_add_right rc_h_loop_locals.range_check_ptr,
      -- Final Proof
      dsimp [auto_spec_squash_dict_inner_block30],
      try { norm_num1 }, try { arith_simps },
      use_only [last_loop_locals, hl_last_loop_locals],
      try { dsimp }, try { arith_simps },
      use_only [a28],
      use_only [a29],
      cases rc_h_loop_locals.range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [a29], arith_simps, exact hn },
      use_only [n_used_accesses, hl_n_used_accesses],
      try { dsimp }, try { arith_simps },
      use_only [a31],
      have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_loop_locals.range_check_ptr,
      have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁,
        try { norm_cast at rc_h_range_check_ptr₁' }, try { rw [add_zero] at rc_h_range_check_ptr₁' },
      use_only [range_check_ptr₁, hl_range_check_ptr₁],
      try { dsimp }, try { arith_simps },
      use_only [remaining_accesses₁, hl_remaining_accesses₁],
      try { dsimp }, try { arith_simps },
      right,
      use_only [a33],
      use_only [next_key],
      right,
      use_only [a42],
      use_only [a44],
      cases rc_h_range_check_ptr₁' (0) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [a44.symm, hl_range_check_ptr₁], arith_simps, exact hn },
      have rc_h_range_check_ptr₂ := range_checked_offset' rc_h_range_check_ptr₁,
      have rc_h_range_check_ptr₂' := range_checked_add_right rc_h_range_check_ptr₂,
        try { norm_cast at rc_h_range_check_ptr₂' }, try { rw [add_zero] at rc_h_range_check_ptr₂' },
      use_only [range_check_ptr₂, hl_range_check_ptr₂],
      try { dsimp }, try { arith_simps },
      use_only [dict_accesses₁, hl_dict_accesses₁],
      try { dsimp }, try { arith_simps },
      use_only [dict_accesses_end_minus1₁, hl_dict_accesses_end_minus1₁],
      try { dsimp }, try { arith_simps },
      use_only [next_key₁, hl_next_key₁],
      try { dsimp }, try { arith_simps },
      use_only [remaining_accesses₂, hl_remaining_accesses₂],
      try { dsimp }, try { arith_simps },
      have rc_h_range_check_ptr₃ := range_checked_offset' rc_h_range_check_ptr₂,
      have rc_h_range_check_ptr₃' := range_checked_add_right rc_h_range_check_ptr₃, try { norm_cast at rc_h_range_check_ptr₃' },
      have h_block54' := h_block54 rc_h_range_check_ptr₂',
      try { rw [←hl_range_check_ptr₁] at h_block54' }, try { rw [←hl_range_check_ptr₂] at h_block54' },
      try { dsimp at h_block54, arith_simps at h_block54' },
      have h_block54 := h_block54',
      use_only [κ_block54],
      use [h_block54],
      try { linarith }
    },
    {
      -- if: negative branch
      have a42 : big_keys ≠ 0, {
        try { simp only [ne.def] },
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps }, try { simp only [hcond] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a42 }, try { arith_simps at a42 },
      clear hcond,
      -- function call
      step_assert_eq hpc56 hpc57 with arg0,
      step_assert_eq hpc58 with arg1,
      step_assert_eq hpc59 with arg2,
      have htv_range_check_ptr₁: range_check_ptr₁ = _,
      { apply eq.symm, apply eq.trans arg0,
        simp only [hl_range_check_ptr₁]; arith_simps; refl },
      step_sub hpc60 (auto_sound_assert_lt_felt mem _ range_check_ptr₁ key next_key _ _ _ _ _),
      { rw hpc61, norm_num2, exact h_mem_1 },
      { rw hpc61, norm_num2, exact h_mem_0 },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps }, try { simp only [arg0, arg1, arg2] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps }, try { simp only [arg0, arg1, arg2] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { arith_simps }, try { simp only [arg0, arg1, arg2] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      intros κ_call62 ap62 h_call62,
      rcases h_call62 with ⟨h_call62_ap_offset, h_call62⟩,
      rcases h_call62 with ⟨rc_m62, rc_mle62, hl_range_check_ptr₂, h_call62⟩,
      mkdef htv_range_check_ptr₂ : range_check_ptr₂ = (mem (ap62 - 1)),
      simp only [←htv_range_check_ptr₂] at h_call62,
      try { rw [←htv_range_check_ptr₂] at hl_range_check_ptr₂ }, try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₂ },
      rw [←htv_range_check_ptr₁, hl_range_check_ptr₁] at h_call62,
      clear arg0 arg1 arg2,
      -- tempvar
      step_assert_eq hpc62 with tv_dict_accesses0,
      set! dict_accesses₁ := (dict_accesses : π_DictAccess mem) with hl_dict_accesses₁,
      have htv_dict_accesses₁: dict_accesses₁ = cast_π_DictAccess mem (mem _), {
        try { simp only [eq_DictAccess_π_ptr_cast ] },
        apply eq.symm, apply eq.trans tv_dict_accesses0,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { simp only [h_call62_ap_offset] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_dict_accesses0,
      try { dsimp at hl_dict_accesses₁ }, try { arith_simps at hl_dict_accesses₁ },
      -- tempvar
      step_assert_eq hpc63 with tv_dict_accesses_end_minus10,
      set! dict_accesses_end_minus1₁ := (dict_accesses_end_minus1 : F) with hl_dict_accesses_end_minus1₁,
      have htv_dict_accesses_end_minus1₁: dict_accesses_end_minus1₁ = _, {
        apply eq.symm, apply eq.trans tv_dict_accesses_end_minus10,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { simp only [h_call62_ap_offset] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_dict_accesses_end_minus10,
      try { dsimp at hl_dict_accesses_end_minus1₁ }, try { arith_simps at hl_dict_accesses_end_minus1₁ },
      -- tempvar
      step_assert_eq hpc64 with tv_next_key0,
      mkdef hl_next_key₁ : next_key₁ = (next_key : F),
      have htv_next_key₁: next_key₁ = _, {
        apply eq.symm, apply eq.trans tv_next_key0,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { simp only [h_call62_ap_offset] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_next_key0,
      try { dsimp at hl_next_key₁ }, try { arith_simps at hl_next_key₁ },
      -- tempvar
      step_assert_eq hpc65 with tv_remaining_accesses0,
      mkdef hl_remaining_accesses₂ : remaining_accesses₂ = (remaining_accesses₁ : F),
      have htv_remaining_accesses₂: remaining_accesses₂ = _, {
        apply eq.symm, apply eq.trans tv_remaining_accesses0,
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂] },
          try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
          try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
          try { simp only [h_call62_ap_offset] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      clear tv_remaining_accesses0,
      try { dsimp at hl_remaining_accesses₂ }, try { arith_simps at hl_remaining_accesses₂ },
      try { simp only [h_call62_ap_offset] },try { arith_simps },
      -- Use the block soundness theorem.
      apply ensuresb_ret_trans (auto_sound_squash_dict_inner_block54 mem σ _ range_check_ptr₂ dict_accesses₁ dict_accesses_end_minus1₁ key remaining_accesses₂ squashed_dict big_keys dict_diff first_value should_skip_loop next_key₁ h_mem_rec h_mem_0 h_mem_1 _ _ _ hin_key _ hin_squashed_dict hin_big_keys hin_dict_diff hin_first_value hin_should_skip_loop _ νbound νih),
      rotate,
      { simp only [htv_range_check_ptr₂], try { simp only [h_call62_ap_offset] }, try { arith_simps }, try { refl } },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { simp only [h_call62_ap_offset] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { simp only [h_call62_ap_offset] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { simp only [h_call62_ap_offset] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_last_loop_locals, hl_n_used_accesses, htv_n_used_accesses, hl_range_check_ptr₁, hl_remaining_accesses₁, htv_remaining_accesses₁, hl_next_key, htv_range_check_ptr₁, htv_range_check_ptr₂, hl_dict_accesses₁, htv_dict_accesses₁, hl_dict_accesses_end_minus1₁, htv_dict_accesses_end_minus1₁, hl_next_key₁, htv_next_key₁, hl_remaining_accesses₂, htv_remaining_accesses₂] },
        try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
        try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
        try { simp only [h_call62_ap_offset] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
      intros κ_block54 τ, try { arith_simps },
      intro h_block54,
      rcases h_block54 with ⟨rc_m_block54, rc_m_le_block54, hblk_range_check_ptr₃, h_block54⟩,
      have hbtv_range_check_ptr₂ := htv_range_check_ptr₂,
      try { simp only [h_call62_ap_offset] at hbtv_range_check_ptr₂ },
      try { arith_simps at hbtv_range_check_ptr₂ },
        try { rw [←hbtv_range_check_ptr₂] at h_block54 }, try { rw [←htv_range_check_ptr₂] at h_block54 }, try { rw [hl_range_check_ptr₂] at h_block54 }, try { rw [←htv_range_check_ptr₁] at h_block54 }, try { rw [hl_range_check_ptr₁] at h_block54 },
      -- range check condition
      use_only (1+rc_m62+rc_m_block54+0+0), split,
      linarith [rc_mle62, rc_m_le_block54],
      split,
      { try { norm_num1 }, arith_simps, try { simp only [hblk_range_check_ptr₃] },
        try { rw [←hbtv_range_check_ptr₂] }, try { rw [←htv_range_check_ptr₂] }, try { rw [hl_range_check_ptr₂] }, try { rw [←htv_range_check_ptr₁] }, try { rw [hl_range_check_ptr₁] },
        try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
      intro rc_h_loop_locals.range_check_ptr, repeat { rw [add_assoc] at rc_h_loop_locals.range_check_ptr },
      have rc_h_loop_locals.range_check_ptr' := range_checked_add_right rc_h_loop_locals.range_check_ptr,
      -- Final Proof
      dsimp [auto_spec_squash_dict_inner_block30],
      try { norm_num1 }, try { arith_simps },
      use_only [last_loop_locals, hl_last_loop_locals],
      try { dsimp }, try { arith_simps },
      use_only [a28],
      use_only [a29],
      cases rc_h_loop_locals.range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
      use_only [n], { simp only [a29], arith_simps, exact hn },
      use_only [n_used_accesses, hl_n_used_accesses],
      try { dsimp }, try { arith_simps },
      use_only [a31],
      have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_loop_locals.range_check_ptr,
      have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁,
        try { norm_cast at rc_h_range_check_ptr₁' }, try { rw [add_zero] at rc_h_range_check_ptr₁' },
      use_only [range_check_ptr₁, hl_range_check_ptr₁],
      try { dsimp }, try { arith_simps },
      use_only [remaining_accesses₁, hl_remaining_accesses₁],
      try { dsimp }, try { arith_simps },
      right,
      use_only [a33],
      use_only [next_key],
      left,
      use_only [a42],
      use_only [κ_call62],
      use_only [range_check_ptr₂],
      have rc_h_range_check_ptr₂ := range_checked_offset' rc_h_range_check_ptr₁,
      have rc_h_range_check_ptr₂' := range_checked_add_right rc_h_range_check_ptr₂, try { norm_cast at rc_h_range_check_ptr₂' },
      have spec62 := h_call62 rc_h_range_check_ptr₁',
        try { rw [←hl_range_check_ptr₁] at spec62 }, try { rw [←htv_range_check_ptr₂] at spec62 },
      try { dsimp at spec62, arith_simps at spec62 },
      use_only [spec62],
      use_only [dict_accesses₁, hl_dict_accesses₁],
      try { dsimp }, try { arith_simps },
      use_only [dict_accesses_end_minus1₁, hl_dict_accesses_end_minus1₁],
      try { dsimp }, try { arith_simps },
      use_only [next_key₁, hl_next_key₁],
      try { dsimp }, try { arith_simps },
      use_only [remaining_accesses₂, hl_remaining_accesses₂],
      try { dsimp }, try { arith_simps },
      have rc_h_range_check_ptr₃ := range_checked_offset' rc_h_range_check_ptr₂,
      have rc_h_range_check_ptr₃' := range_checked_add_right rc_h_range_check_ptr₃, try { norm_cast at rc_h_range_check_ptr₃' },
      have h_block54' := h_block54 rc_h_range_check_ptr₂',
      try { rw [←hl_range_check_ptr₁] at h_block54' }, try { rw [←hl_range_check_ptr₂] at h_block54' },
      try { dsimp at h_block54, arith_simps at h_block54' },
      have h_block54 := h_block54',
      use_only [κ_block54],
      use [h_block54],
      try { linarith }
    }
  }
end

theorem auto_sound_squash_dict_inner_block17
    -- An independent ap variable.
    (ap : F)
    -- arguments
    (range_check_ptr : F) (dict_accesses : π_DictAccess mem) (dict_accesses_end_minus1 key remaining_accesses : F) (squashed_dict : π_DictAccess mem) (big_keys : F) (dict_diff : π_DictAccess mem) (first_value should_skip_loop : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_squash_dict_inner σ.pc)
    -- all dependencies are in memory
    (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 84))
    (h_mem_1 : mem_at mem code_assert_lt_felt (σ.pc  - 39))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
    (hin_dict_accesses : dict_accesses = cast_π_DictAccess mem (mem (σ.fp - 8)))
    (hin_dict_accesses_end_minus1 : dict_accesses_end_minus1 = mem (σ.fp - 7))
    (hin_key : key = mem (σ.fp - 6))
    (hin_remaining_accesses : remaining_accesses = mem (σ.fp - 5))
    (hin_squashed_dict : squashed_dict = cast_π_DictAccess mem (mem (σ.fp - 4)))
    (hin_big_keys : big_keys = mem (σ.fp - 3))
    (hin_dict_diff : dict_diff = cast_π_DictAccess mem (mem (σ.fp - 4)))
    (hin_first_value : first_value = mem σ.fp)
    (hin_should_skip_loop : should_skip_loop = mem (σ.fp + 1))
    (νbound : ℕ)
    (νih : ∀ (σ : register_state F)
             (range_check_ptr : F) (dict_accesses : π_DictAccess mem) (dict_accesses_end_minus1 key remaining_accesses : F) (squashed_dict : π_DictAccess mem) (big_keys : F)
             (h_mem : mem_at mem code_squash_dict_inner σ.pc)
             (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 84))
             (h_mem_1 : mem_at mem code_assert_lt_felt (σ.pc  - 39))
             (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
             (hin_dict_accesses : dict_accesses = cast_π_DictAccess mem (mem (σ.fp - 8)))
             (hin_dict_accesses_end_minus1 : dict_accesses_end_minus1 = mem (σ.fp - 7))
             (hin_key : key = mem (σ.fp - 6))
             (hin_remaining_accesses : remaining_accesses = mem (σ.fp - 5))
             (hin_squashed_dict : squashed_dict = cast_π_DictAccess mem (mem (σ.fp - 4)))
             (hin_big_keys : big_keys = mem (σ.fp - 3)),
             ensuresb_ret νbound mem σ (λ κ τ,
               ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 9)) (mem $ τ.ap - 2)
                 (spec_squash_dict_inner mem κ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys (mem (τ.ap - 2)) (cast_π_DictAccess  mem (mem (τ.ap - 1))))))
    -- conclusion
  : ensuresb_ret νbound mem
    {pc := σ.pc + 15, ap := ap, fp := σ.fp}
    (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (ap - 1)) (mem $ τ.ap - 2)
        (auto_spec_squash_dict_inner_block17 mem κ ap range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop (mem (τ.ap - 2)) (cast_π_DictAccess  mem (mem (τ.ap - 1))))) :=
begin
  apply ensuresb_of_ensuresb, intros νbound₁₇ νbound_h₁₇, 
  revert σ ap range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop h_mem h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys hin_dict_diff hin_first_value hin_should_skip_loop νbound νih,
  induction νbound₁₇ with νbound₁₇ νih₁₇,
  { intros, intros n nlt, apply absurd nlt (nat.not_lt_zero _) },
  intros σ ap range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop h_mem h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys hin_dict_diff hin_first_value hin_should_skip_loop νbound νih νbound_h₁₇,
  dsimp at νih₁₇,
  have νbound_h₁₇ := le_of_lt (nat.succ_le_iff.mp νbound_h₁₇),
  have h_mem_rec := h_mem,
  unpack_memory code_squash_dict_inner at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45, hpc46, hpc47, hpc48, hpc49, hpc50, hpc51, hpc52, hpc53, hpc54, hpc55, hpc56, hpc57, hpc58, hpc59, hpc60, hpc61, hpc62, hpc63, hpc64, hpc65, hpc66, hpc67, hpc68, hpc69, hpc70, hpc71⟩,
  -- let
  set! prev_loop_locals := (squash_dict_inner.cast_π_LoopLocals mem (ap - squash_dict_inner.LoopLocals.SIZE) : squash_dict_inner.π_LoopLocals mem) with hl_prev_loop_locals,
  try { dsimp at hl_prev_loop_locals }, try { arith_simps at hl_prev_loop_locals },
  -- let
  set! loop_temps := (squash_dict_inner.cast_π_LoopTemps mem ap : squash_dict_inner.π_LoopTemps mem) with hl_loop_temps,
  try { dsimp at hl_loop_temps }, try { arith_simps at hl_loop_temps },
  -- let
  set! loop_locals := (squash_dict_inner.cast_π_LoopLocals mem (ap + squash_dict_inner.LoopTemps.SIZE) : squash_dict_inner.π_LoopLocals mem) with hl_loop_locals,
  try { dsimp at hl_loop_locals }, try { arith_simps at hl_loop_locals },
  -- assert eq
  step_assert_eq hpc15 with temp0,
  have a15: loop_temps.index_delta_minus1 = mem prev_loop_locals.range_check_ptr, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a15 }, try { arith_simps at a15 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc16 hpc17 with temp0,
  have a16: loop_temps.index_delta = loop_temps.index_delta_minus1 + 1, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a16 }, try { arith_simps at a16 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc18 hpc19 with temp0,
  have a18: loop_temps.ptr_delta = loop_temps.index_delta * DictAccess.SIZE, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a18 }, try { arith_simps at a18 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc20 with temp0,
  have a20: loop_locals.access_ptr = cast_π_DictAccess mem (prev_loop_locals.access_ptr + loop_temps.ptr_delta), {
    try { apply eq_DictAccess_ptr },
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a20 }, try { arith_simps at a20 },
  clear temp0,
  -- let
  set! access := (loop_locals.access_ptr : π_DictAccess mem) with hl_access,
  try { dsimp at hl_access }, try { arith_simps at hl_access },
  -- assert eq
  step_assert_eq hpc21 with temp0,
  have a21: prev_loop_locals.value = access.prev_value, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals, hl_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a21 }, try { arith_simps at a21 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc22 with temp0,
  have a22: loop_locals.value = access.new_value, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals, hl_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a22 }, try { arith_simps at a22 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc23 with temp0,
  have a23: key = access.key, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals, hl_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a23 }, try { arith_simps at a23 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc24 hpc25 with temp0,
  have a24: loop_locals.range_check_ptr = prev_loop_locals.range_check_ptr + 1, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals, hl_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a24 }, try { arith_simps at a24 },
  clear temp0,
  -- jnz
  step_jnz hpc26 hpc27 with hcond hcond,
  {
    -- jnz: positive branch
    have a26 : loop_temps.should_continue = 0, {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals, hl_access] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a26 }, try { arith_simps at a26 },
    clear hcond,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (ensuresb_of_le νbound_h₁₇ (auto_sound_squash_dict_inner_block30 mem σ _ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop h_mem_rec h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys hin_dict_diff hin_first_value hin_should_skip_loop νbound νih)),
    intros κ_block30 τ, try { arith_simps },
    intro h_block30,
    rcases h_block30 with ⟨rc_m_block30, rc_m_le_block30, hblk_loop_locals.range_check_ptr₁, h_block30⟩,
      try { rw [a24] at h_block30 },
    -- range check condition
    use_only (1+rc_m_block30+0+0), split,
    linarith [rc_m_le_block30],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hblk_loop_locals.range_check_ptr₁] },
      try { rw [a24] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_first_loop_locals.range_check_ptr, repeat { rw [add_assoc] at rc_h_first_loop_locals.range_check_ptr },
    have rc_h_first_loop_locals.range_check_ptr' := range_checked_add_right rc_h_first_loop_locals.range_check_ptr,
    -- Final Proof
    dsimp [auto_spec_squash_dict_inner_block17],
    try { norm_num1 }, try { arith_simps },
    use_only [prev_loop_locals, hl_prev_loop_locals],
    try { dsimp }, try { arith_simps },
    use_only [loop_temps, hl_loop_temps],
    try { dsimp }, try { arith_simps },
    use_only [loop_locals, hl_loop_locals],
    try { dsimp }, try { arith_simps },
    use_only [a15],
    cases rc_h_first_loop_locals.range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [a15], arith_simps, exact hn },
    use_only [a16],
    use_only [a18],
    use_only [a20],
    use_only [access, hl_access],
    try { dsimp }, try { arith_simps },
    use_only [a21],
    use_only [a22],
    use_only [a23],
    have rc_h_loop_locals.range_check_ptr := range_checked_offset' rc_h_first_loop_locals.range_check_ptr,
    have rc_h_loop_locals.range_check_ptr' := range_checked_add_right rc_h_loop_locals.range_check_ptr,
      try { norm_cast at rc_h_loop_locals.range_check_ptr' }, try { arith_simps at rc_h_loop_locals.range_check_ptr' },
    use_only [a24],
    left,
    use_only [a26],
    have rc_h_loop_locals.range_check_ptr₁ := range_checked_offset' rc_h_loop_locals.range_check_ptr,
    have rc_h_loop_locals.range_check_ptr₁' := range_checked_add_right rc_h_loop_locals.range_check_ptr₁, try { norm_cast at rc_h_loop_locals.range_check_ptr₁' },
    have h_block30' := h_block30 rc_h_loop_locals.range_check_ptr',
    try { rw [←hl_loop_locals.range_check_ptr] at h_block30' },
    try { dsimp at h_block30, arith_simps at h_block30' },
    have h_block30 := h_block30',
    use_only [κ_block30],
    use [h_block30],
    try { linarith }
  },
  {
    -- jnz: negative branch
    have a26 : loop_temps.should_continue ≠ 0, {
      try { simp only [ne.def] },
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hin_dict_diff, hin_first_value, hin_should_skip_loop, hl_prev_loop_locals, hl_loop_temps, hl_loop_locals, hl_access] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast, squash_dict_inner.eq_LoopTemps_π_cast, squash_dict_inner.coe_LoopTemps_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals, squash_dict_inner.cast_π_LoopTemps] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a26 }, try { arith_simps at a26 },
    clear hcond,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (νih₁₇ _ _ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop h_mem_rec h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys hin_dict_diff hin_first_value hin_should_skip_loop νbound νih νbound_h₁₇),
    intros κ_block17 τ, try { arith_simps },
    intro h_block17,
    rcases h_block17 with ⟨rc_m_block17, rc_m_le_block17, hblk_first_loop_locals.range_check_ptr, h_block17⟩,
      try { rw [a24] at h_block17 },
    -- range check condition
    use_only (1+rc_m_block17+0+0), split,
    linarith [rc_m_le_block17],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hblk_first_loop_locals.range_check_ptr] },
      try { rw [a24] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_first_loop_locals.range_check_ptr, repeat { rw [add_assoc] at rc_h_first_loop_locals.range_check_ptr },
    have rc_h_first_loop_locals.range_check_ptr' := range_checked_add_right rc_h_first_loop_locals.range_check_ptr,
    -- Final Proof
    dsimp [auto_spec_squash_dict_inner_block17],
    try { norm_num1 }, try { arith_simps },
    use_only [prev_loop_locals, hl_prev_loop_locals],
    try { dsimp }, try { arith_simps },
    use_only [loop_temps, hl_loop_temps],
    try { dsimp }, try { arith_simps },
    use_only [loop_locals, hl_loop_locals],
    try { dsimp }, try { arith_simps },
    use_only [a15],
    cases rc_h_first_loop_locals.range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [a15], arith_simps, exact hn },
    use_only [a16],
    use_only [a18],
    use_only [a20],
    use_only [access, hl_access],
    try { dsimp }, try { arith_simps },
    use_only [a21],
    use_only [a22],
    use_only [a23],
    have rc_h_loop_locals.range_check_ptr := range_checked_offset' rc_h_first_loop_locals.range_check_ptr,
    have rc_h_loop_locals.range_check_ptr' := range_checked_add_right rc_h_loop_locals.range_check_ptr,
      try { norm_cast at rc_h_loop_locals.range_check_ptr' }, try { arith_simps at rc_h_loop_locals.range_check_ptr' },
    use_only [a24],
    right,
    use_only [a26],
    have rc_h_first_loop_locals.range_check_ptr := range_checked_offset' rc_h_loop_locals.range_check_ptr,
    have rc_h_first_loop_locals.range_check_ptr' := range_checked_add_right rc_h_first_loop_locals.range_check_ptr, try { norm_cast at rc_h_first_loop_locals.range_check_ptr' },
    have h_block17' := h_block17 rc_h_loop_locals.range_check_ptr',
    try { rw [←hl_loop_locals.range_check_ptr] at h_block17' },
    try { dsimp at h_block17, arith_simps at h_block17' },
    have h_block17 := h_block17',
    use_only [κ_block17],
    use [sound_squash_dict_inner_block17 _ _ _ _ _ _ _ _ _ _ _ _ _ _ h_block17],
    try { linarith }
  }
end

theorem auto_sound_squash_dict_inner
    -- arguments
    (range_check_ptr : F) (dict_accesses : π_DictAccess mem) (dict_accesses_end_minus1 key remaining_accesses : F) (squashed_dict : π_DictAccess mem) (big_keys : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_squash_dict_inner σ.pc)
    -- all dependencies are in memory
    (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 84))
    (h_mem_1 : mem_at mem code_assert_lt_felt (σ.pc  - 39))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
    (hin_dict_accesses : dict_accesses = cast_π_DictAccess mem (mem (σ.fp - 8)))
    (hin_dict_accesses_end_minus1 : dict_accesses_end_minus1 = mem (σ.fp - 7))
    (hin_key : key = mem (σ.fp - 6))
    (hin_remaining_accesses : remaining_accesses = mem (σ.fp - 5))
    (hin_squashed_dict : squashed_dict = cast_π_DictAccess mem (mem (σ.fp - 4)))
    (hin_big_keys : big_keys = mem (σ.fp - 3))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 9)) (mem $ τ.ap - 2)
        (spec_squash_dict_inner mem κ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys (mem (τ.ap - 2)) (cast_π_DictAccess  mem (mem (τ.ap - 1))))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  revert σ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys h_mem h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys,
  induction νbound with νbound νih,
  { intros, intros n nlt, apply absurd nlt (nat.not_lt_zero _) },
  intros σ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys h_mem h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys,
  dsimp at νih,
  have h_mem_rec := h_mem,
  unpack_memory code_squash_dict_inner at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45, hpc46, hpc47, hpc48, hpc49, hpc50, hpc51, hpc52, hpc53, hpc54, hpc55, hpc56, hpc57, hpc58, hpc59, hpc60, hpc61, hpc62, hpc63, hpc64, hpc65, hpc66, hpc67, hpc68, hpc69, hpc70, hpc71⟩,
  -- ap += 2
  step_advance_ap hpc0 hpc1,
  -- let
  set! dict_diff := (squashed_dict : π_DictAccess mem) with hl_dict_diff,
  try { dsimp at hl_dict_diff }, try { arith_simps at hl_dict_diff },
  -- tempvar
  step_assert_eq hpc2 with tv_current_access_index0,
  mkdef hl_current_access_index : current_access_index = (mem range_check_ptr : F),
  have htv_current_access_index: current_access_index = _, {
    apply eq.symm, apply eq.trans tv_current_access_index0,
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
      try { dsimp [cast_π_DictAccess] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_current_access_index0,
  try { dsimp at hl_current_access_index }, try { arith_simps at hl_current_access_index },
  -- tempvar
  step_assert_eq hpc3 hpc4 with tv_ptr_delta0,
  mkdef hl_ptr_delta : ptr_delta = (current_access_index * DictAccess.SIZE : F),
  have htv_ptr_delta: ptr_delta = _, {
    apply eq.symm, apply eq.trans tv_ptr_delta0,
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast] },
      try { dsimp [cast_π_DictAccess] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_ptr_delta0,
  try { dsimp at hl_ptr_delta }, try { arith_simps at hl_ptr_delta },
  -- let
  set! first_loop_locals := (squash_dict_inner.cast_π_LoopLocals mem (σ.ap + 4) : squash_dict_inner.π_LoopLocals mem) with hl_first_loop_locals,
  try { dsimp at hl_first_loop_locals }, try { arith_simps at hl_first_loop_locals },
  -- assert eq
  step_assert_eq hpc5 with temp0,
  have a5: first_loop_locals.access_ptr = cast_π_DictAccess mem (dict_accesses + ptr_delta), {
    try { apply eq_DictAccess_ptr },
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a5 }, try { arith_simps at a5 },
  clear temp0,
  -- let
  set! first_access := (first_loop_locals.access_ptr : π_DictAccess mem) with hl_first_access,
  try { dsimp at hl_first_access }, try { arith_simps at hl_first_access },
  -- assert eq
  step_assert_eq hpc6 with temp0,
  have a6: first_loop_locals.value = first_access.new_value, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a6 }, try { arith_simps at a6 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc7 hpc8 with temp0,
  have a7: first_loop_locals.range_check_ptr = range_check_ptr + 1, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a7 }, try { arith_simps at a7 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc9 with temp0,
  have a9: key = first_access.key, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a9 }, try { arith_simps at a9 },
  clear temp0,
  -- assert eq
  step_assert_eq hpc10 with temp0,
  have a10: key = dict_diff.key, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a10 }, try { arith_simps at a10 },
  clear temp0,
  -- local var
  mkdef lc_first_value : first_value = (mem (σ.fp)),
  -- compound assert eq
  step_assert_eq hpc11 with temp0,
  have a11: first_value = first_access.prev_value, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access, lc_first_value] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a11 }, try { arith_simps at a11 },
  clear temp0,
  -- compound assert eq
  step_assert_eq hpc12 with temp0,
  have a12: first_value = dict_diff.prev_value, {
    apply assert_eq_reduction temp0,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access, lc_first_value] },
    try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
    try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a12 }, try { arith_simps at a12 },
  clear temp0,
  -- local var
  mkdef lc_should_skip_loop : should_skip_loop = (mem (σ.fp + 1)),
  -- jnz
  step_jnz hpc13 hpc14 with hcond hcond,
  {
    -- jnz: positive branch
    have a13 : should_skip_loop = 0, {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access, lc_first_value, lc_should_skip_loop] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a13 }, try { arith_simps at a13 },
    clear hcond,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (auto_sound_squash_dict_inner_block17 mem σ _ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop h_mem_rec h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys _ lc_first_value lc_should_skip_loop νbound νih),
    rotate,
    { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access, lc_first_value, lc_should_skip_loop] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
    intros κ_block17 τ, try { arith_simps },
    intro h_block17,
    rcases h_block17 with ⟨rc_m_block17, rc_m_le_block17, hblk_first_loop_locals.range_check_ptr₁, h_block17⟩,
      try { rw [a7] at h_block17 }, try { rw [hin_range_check_ptr] at h_block17 },
    -- range check condition
    use_only (1+rc_m_block17+0+0), split,
    linarith [rc_m_le_block17],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hblk_first_loop_locals.range_check_ptr₁] },
      try { rw [a7] }, try { rw [hin_range_check_ptr] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
    have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
    -- Final Proof
    -- user-provided reduction
    suffices auto_spec: auto_spec_squash_dict_inner mem _ _ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys _ _,
    { apply sound_squash_dict_inner, apply auto_spec },
    -- prove the auto generated assertion
    dsimp [auto_spec_squash_dict_inner],
    try { norm_num1 }, try { arith_simps },
    use_only [dict_diff, hl_dict_diff],
    try { dsimp }, try { arith_simps },
    use_only [current_access_index, hl_current_access_index],
    try { dsimp }, try { arith_simps },
    cases rc_h_range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [hl_current_access_index, hin_range_check_ptr], arith_simps, exact hn },
    use_only [ptr_delta, hl_ptr_delta],
    try { dsimp }, try { arith_simps },
    use_only [first_loop_locals, hl_first_loop_locals],
    try { dsimp }, try { arith_simps },
    use_only [a5],
    use_only [first_access, hl_first_access],
    try { dsimp }, try { arith_simps },
    use_only [a6],
    have rc_h_first_loop_locals.range_check_ptr := range_checked_offset' rc_h_range_check_ptr,
    have rc_h_first_loop_locals.range_check_ptr' := range_checked_add_right rc_h_first_loop_locals.range_check_ptr,
      try { norm_cast at rc_h_first_loop_locals.range_check_ptr' }, try { arith_simps at rc_h_first_loop_locals.range_check_ptr' },
    use_only [a7],
    use_only [a9],
    use_only [a10],
    use_only [first_value],
    use_only [a11],
    use_only [a12],
    use_only [should_skip_loop],
    left,
    use_only [a13],
    have rc_h_first_loop_locals.range_check_ptr₁ := range_checked_offset' rc_h_first_loop_locals.range_check_ptr,
    have rc_h_first_loop_locals.range_check_ptr₁' := range_checked_add_right rc_h_first_loop_locals.range_check_ptr₁, try { norm_cast at rc_h_first_loop_locals.range_check_ptr₁' },
    have h_block17' := h_block17 rc_h_first_loop_locals.range_check_ptr',
    try { rw [←hin_range_check_ptr] at h_block17' }, try { rw [←hl_first_loop_locals.range_check_ptr] at h_block17' },
    try { dsimp at h_block17, arith_simps at h_block17' },
    have h_block17 := h_block17',
    use_only [κ_block17],
    use [h_block17],
    try { linarith }
  },
  {
    -- jnz: negative branch
    have a13 : should_skip_loop ≠ 0, {
      try { simp only [ne.def] },
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access, lc_first_value, lc_should_skip_loop] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a13 }, try { arith_simps at a13 },
    clear hcond,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (auto_sound_squash_dict_inner_block30 mem σ _ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys dict_diff first_value should_skip_loop h_mem_rec h_mem_0 h_mem_1 hin_range_check_ptr hin_dict_accesses hin_dict_accesses_end_minus1 hin_key hin_remaining_accesses hin_squashed_dict hin_big_keys _ lc_first_value lc_should_skip_loop νbound νih),
    rotate,
    { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_dict_accesses, hin_dict_accesses_end_minus1, hin_key, hin_remaining_accesses, hin_squashed_dict, hin_big_keys, hl_dict_diff, hl_current_access_index, htv_current_access_index, hl_ptr_delta, htv_ptr_delta, hl_first_loop_locals, hl_first_access, lc_first_value, lc_should_skip_loop] },
      try { simp only [eq_DictAccess_π_cast, coe_DictAccess_π_cast, squash_dict_inner.eq_LoopLocals_π_cast, squash_dict_inner.coe_LoopLocals_π_cast] },
      try { dsimp [cast_π_DictAccess, squash_dict_inner.cast_π_LoopLocals] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
    intros κ_block30 τ, try { arith_simps },
    intro h_block30,
    rcases h_block30 with ⟨rc_m_block30, rc_m_le_block30, hblk_loop_locals.range_check_ptr, h_block30⟩,
      try { rw [a7] at h_block30 }, try { rw [hin_range_check_ptr] at h_block30 },
    -- range check condition
    use_only (1+rc_m_block30+0+0), split,
    linarith [rc_m_le_block30],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hblk_loop_locals.range_check_ptr] },
      try { rw [a7] }, try { rw [hin_range_check_ptr] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
    have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
    -- Final Proof
    -- user-provided reduction
    suffices auto_spec: auto_spec_squash_dict_inner mem _ _ range_check_ptr dict_accesses dict_accesses_end_minus1 key remaining_accesses squashed_dict big_keys _ _,
    { apply sound_squash_dict_inner, apply auto_spec },
    -- prove the auto generated assertion
    dsimp [auto_spec_squash_dict_inner],
    try { norm_num1 }, try { arith_simps },
    use_only [dict_diff, hl_dict_diff],
    try { dsimp }, try { arith_simps },
    use_only [current_access_index, hl_current_access_index],
    try { dsimp }, try { arith_simps },
    cases rc_h_range_check_ptr' (0) (by norm_num1) with n hn, arith_simps at hn,
    use_only [n], { simp only [hl_current_access_index, hin_range_check_ptr], arith_simps, exact hn },
    use_only [ptr_delta, hl_ptr_delta],
    try { dsimp }, try { arith_simps },
    use_only [first_loop_locals, hl_first_loop_locals],
    try { dsimp }, try { arith_simps },
    use_only [a5],
    use_only [first_access, hl_first_access],
    try { dsimp }, try { arith_simps },
    use_only [a6],
    have rc_h_first_loop_locals.range_check_ptr := range_checked_offset' rc_h_range_check_ptr,
    have rc_h_first_loop_locals.range_check_ptr' := range_checked_add_right rc_h_first_loop_locals.range_check_ptr,
      try { norm_cast at rc_h_first_loop_locals.range_check_ptr' }, try { arith_simps at rc_h_first_loop_locals.range_check_ptr' },
    use_only [a7],
    use_only [a9],
    use_only [a10],
    use_only [first_value],
    use_only [a11],
    use_only [a12],
    use_only [should_skip_loop],
    right,
    use_only [a13],
    have rc_h_loop_locals.range_check_ptr := range_checked_offset' rc_h_first_loop_locals.range_check_ptr,
    have rc_h_loop_locals.range_check_ptr' := range_checked_add_right rc_h_loop_locals.range_check_ptr, try { norm_cast at rc_h_loop_locals.range_check_ptr' },
    have h_block30' := h_block30 rc_h_first_loop_locals.range_check_ptr',
    try { rw [←hin_range_check_ptr] at h_block30' }, try { rw [←hl_first_loop_locals.range_check_ptr] at h_block30' },
    try { dsimp at h_block30, arith_simps at h_block30' },
    have h_block30 := h_block30',
    use_only [κ_block30],
    use [h_block30],
    try { linarith }
  }
end

