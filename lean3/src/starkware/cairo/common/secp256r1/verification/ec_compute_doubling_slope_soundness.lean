/-
File: ec_compute_doubling_slope_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .ec_code
import ..ec_spec
import .ec_verify_zero_soundness
import .ec_nondet_bigint3_soundness
import .ec_unreduced_sqr_soundness
import .ec_unreduced_mul_soundness
open tactic

open starkware.cairo.common.secp256r1.ec
open starkware.cairo.common.cairo_secp.ec_point
open starkware.cairo.common.secp256r1.field
open starkware.cairo.common.secp256r1.bigint
open starkware.cairo.common.cairo_secp.bigint3
open starkware.cairo.common.secp256r1.constants

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.secp256r1.ec.compute_doubling_slope autogenerated soundness theorem -/

theorem auto_sound_compute_doubling_slope
    -- arguments
    (range_check_ptr : F) (point : EcPoint mem)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_compute_doubling_slope σ.pc)
    -- all dependencies are in memory
    (h_mem_4 : mem_at mem code_nondet_bigint3 (σ.pc  - 219))
    (h_mem_5 : mem_at mem code_unreduced_mul (σ.pc  - 206))
    (h_mem_6 : mem_at mem code_unreduced_sqr (σ.pc  - 168))
    (h_mem_7 : mem_at mem code_assert_165_bit (σ.pc  - 134))
    (h_mem_8 : mem_at mem code_verify_zero (σ.pc  - 123))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 9))
    (hin_point : point = cast_EcPoint mem (σ.fp - 8))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      τ.ap = σ.ap + 141 ∧
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 9)) (mem $ τ.ap - 4)
        (spec_compute_doubling_slope mem κ range_check_ptr point (mem (τ.ap - 4)) (cast_BigInt3  mem (τ.ap - 3)))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  have h_mem_rec := h_mem,
  unpack_memory code_compute_doubling_slope at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45⟩,
  -- function call
  step_assert_eq hpc0 with arg0,
  step_sub hpc1 (auto_sound_nondet_bigint3 mem _ range_check_ptr _ _),
  { rw hpc2, norm_num2, exact h_mem_4 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point] },
    try { dsimp [cast_EcPoint, cast_BigInt3] },
    try { arith_simps }, try { simp only [arg0] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call3 ap3 h_call3,
  rcases h_call3 with ⟨h_call3_ap_offset, h_call3⟩,
  rcases h_call3 with ⟨rc_m3, rc_mle3, hl_range_check_ptr₁, h_call3⟩,
  mkdef htv_range_check_ptr₁ : range_check_ptr₁ = (mem (ap3 - 4)),
  simp only [←htv_range_check_ptr₁] at h_call3,
  mkdef htv_slope : slope = (cast_BigInt3 mem (ap3 - 3)),
  simp only [←htv_slope] at h_call3,
  try { simp only [arg0] at hl_range_check_ptr₁ },
  try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₁ }, try { rw [←hin_range_check_ptr] at hl_range_check_ptr₁ },
  try { simp only [arg0] at h_call3 },
  rw [hin_range_check_ptr] at h_call3,
  clear arg0,
  -- function call
  step_assert_eq hpc3 with arg0,
  step_assert_eq hpc4 with arg1,
  step_assert_eq hpc5 with arg2,
  step_sub hpc6 (auto_sound_unreduced_sqr mem _ point.x _ _),
  { rw hpc7, norm_num2, exact h_mem_6 },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2] },
      try { simp only [h_call3_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call8 ap8 h_call8,
  rcases h_call8 with ⟨h_call8_ap_offset, h_call8⟩,
  mkdef htv_x_sqr : x_sqr = (cast_UnreducedBigInt3 mem (ap8 - 3)),
  simp only [←htv_x_sqr] at h_call8,
  clear arg0 arg1 arg2,
  -- function call
  step_assert_eq hpc8 with arg0,
  step_assert_eq hpc9 with arg1,
  step_assert_eq hpc10 with arg2,
  step_assert_eq hpc11 with arg3,
  step_assert_eq hpc12 with arg4,
  step_assert_eq hpc13 with arg5,
  step_sub hpc14 (auto_sound_unreduced_mul mem _ slope point.y _ _ _),
  { rw hpc15, norm_num2, exact h_mem_5 },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5] },
      try { simp only [h_call3_ap_offset, h_call8_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5] },
      try { simp only [h_call3_ap_offset, h_call8_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call16 ap16 h_call16,
  rcases h_call16 with ⟨h_call16_ap_offset, h_call16⟩,
  mkdef htv_slope_y : slope_y = (cast_UnreducedBigInt3 mem (ap16 - 3)),
  simp only [←htv_slope_y] at h_call16,
  clear arg0 arg1 arg2 arg3 arg4 arg5,
  -- function call
  step_assert_eq hpc16 hpc17 with arg0,
  step_assert_eq hpc18 with arg1,
  step_assert_eq hpc19 hpc20 with arg2,
  step_assert_eq hpc21 hpc22 with arg3,
  step_assert_eq hpc23 with arg4,
  step_assert_eq hpc24 hpc25 with arg5,
  step_assert_eq hpc26 with arg6,
  step_assert_eq hpc27 hpc28 with arg7,
  step_assert_eq hpc29 with arg8,
  step_assert_eq hpc30 hpc31 with arg9,
  step_assert_eq hpc32 with arg10,
  step_assert_eq hpc33 hpc34 with arg11,
  step_assert_eq hpc35 with arg12,
  step_assert_eq hpc36 with arg13,
  step_assert_eq hpc37 with arg14,
  step_assert_eq hpc38 with arg15,
  step_assert_eq hpc39 with arg16,
  step_sub hpc40 (auto_sound_verify_zero mem _ range_check_ptr₁ {
    d0 := 3 * x_sqr.d0 + ALPHA - 2 * slope_y.d0,
    d1 := 3 * x_sqr.d1 - 2 * slope_y.d1,
    d2 := 3 * x_sqr.d2 - 2 * slope_y.d2
  } _ _ _ _),
  { rw hpc41, norm_num2, exact h_mem_8 },
  { rw hpc41, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr, htv_slope_y] },
    try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, (eq_sub_of_eq_add arg14), (eq_sub_of_eq_add arg15), (eq_sub_of_eq_add arg16)] },
    try { simp only [h_call3_ap_offset, h_call8_ap_offset, h_call16_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr, htv_slope_y] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, (eq_sub_of_eq_add arg14), (eq_sub_of_eq_add arg15), (eq_sub_of_eq_add arg16)] },
      try { simp only [h_call3_ap_offset, h_call8_ap_offset, h_call16_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call42 ap42 h_call42,
  rcases h_call42 with ⟨h_call42_ap_offset, h_call42⟩,
  rcases h_call42 with ⟨rc_m42, rc_mle42, hl_range_check_ptr₂, h_call42⟩,
  mkdef htv_range_check_ptr₂ : range_check_ptr₂ = (mem (ap42 - 1)),
  simp only [←htv_range_check_ptr₂] at h_call42,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10 ,arg11 ,arg12 ,arg13 ,arg14 ,arg15 ,arg16] at hl_range_check_ptr₂ },
  try { rw [h_call16_ap_offset, h_call8_ap_offset] at hl_range_check_ptr₂ }, try { arith_simps at hl_range_check_ptr₂ },
  try { rw [←htv_range_check_ptr₂] at hl_range_check_ptr₂ }, try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₂ },
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10 ,arg11 ,arg12 ,arg13 ,arg14 ,arg15 ,arg16] at h_call42 },
  try { rw [h_call16_ap_offset, h_call8_ap_offset] at h_call42 }, try { arith_simps at h_call42 },
  rw [←htv_range_check_ptr₁, hl_range_check_ptr₁, hin_range_check_ptr] at h_call42,
  clear arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12 arg13 arg14 arg15 arg16,
  -- return
  step_assert_eq hpc42 with hret0,
  step_assert_eq hpc43 with hret1,
  step_assert_eq hpc44 with hret2,
  step_ret hpc45,
  -- finish
  step_done, use_only [rfl, rfl],
  split,
  { try { simp only [h_call3_ap_offset ,h_call8_ap_offset ,h_call16_ap_offset ,h_call42_ap_offset] },
    try { arith_simps }, try { refl } },
  -- range check condition
  use_only (rc_m3+rc_m42+0+0), split,
  linarith [rc_mle3, rc_mle42],
  split,
  { try { norm_num1 }, arith_simps, try { simp only [hret0 ,hret1 ,hret2] },
    try { rw [←htv_range_check_ptr₂] }, try { rw [hl_range_check_ptr₂] }, try { rw [←htv_range_check_ptr₁] }, try { rw [hl_range_check_ptr₁] }, try { rw [hin_range_check_ptr] },
    try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
  intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
  have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
  -- Final Proof
  -- user-provided reduction
  suffices auto_spec: auto_spec_compute_doubling_slope mem _ range_check_ptr point _ _,
  { apply sound_compute_doubling_slope, apply auto_spec },
  -- prove the auto generated assertion
  dsimp [auto_spec_compute_doubling_slope],
  try { norm_num1 }, try { arith_simps },
  use_only [κ_call3],
  use_only [range_check_ptr₁],
  use_only [slope],
  have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
  have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
  have spec3 := h_call3 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at spec3 }, try { rw [←htv_range_check_ptr₁] at spec3 },
  try { dsimp at spec3, arith_simps at spec3 },
  use_only [spec3],
  use_only [κ_call8],
  use_only [x_sqr],
  try { dsimp at h_call8, arith_simps at h_call8 },
  try { use_only [h_call8] },
  use_only [κ_call16],
  use_only [slope_y],
  try { dsimp at h_call16, arith_simps at h_call16 },
  try { use_only [h_call16] },
  use_only [κ_call42],
  use_only [range_check_ptr₂],
  have rc_h_range_check_ptr₂ := range_checked_offset' rc_h_range_check_ptr₁,
  have rc_h_range_check_ptr₂' := range_checked_add_right rc_h_range_check_ptr₂, try { norm_cast at rc_h_range_check_ptr₂' },
  have spec42 := h_call42 rc_h_range_check_ptr₁',
    try { rw [←hin_range_check_ptr] at spec42 }, try { rw [←hl_range_check_ptr₁] at spec42 }, try { rw [←htv_range_check_ptr₂] at spec42 },
  try { dsimp at spec42, arith_simps at spec42 },
  use_only [spec42],
  try { split, trivial <|> linarith },
  try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point, htv_range_check_ptr₁, htv_slope, htv_x_sqr, htv_slope_y, htv_range_check_ptr₂] }, },
  try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
  try { arith_simps }, try { simp only [hret0, hret1, hret2] },
  try { simp only [h_call3_ap_offset, h_call8_ap_offset, h_call16_ap_offset, h_call42_ap_offset] },
  try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
end

