/-
File: ec_verify_zero_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .ec_code
import ..ec_spec
import .ec_assert_165_bit_soundness
open tactic

open starkware.cairo.common.secp256r1.field
open starkware.cairo.common.cairo_secp.bigint3
open starkware.cairo.common.secp256r1.constants

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.secp256r1.field.verify_zero autogenerated soundness theorem -/

theorem auto_sound_verify_zero
    -- arguments
    (range_check_ptr : F) (val : UnreducedBigInt3 mem)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_verify_zero σ.pc)
    -- all dependencies are in memory
    (h_mem_7 : mem_at mem code_assert_165_bit (σ.pc  - 11))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 6))
    (hin_val : val = cast_UnreducedBigInt3 mem (σ.fp - 5))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      τ.ap = σ.ap + 38 ∧
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 6)) (mem $ τ.ap - 1)
        (spec_verify_zero mem κ range_check_ptr val (mem (τ.ap - 1)))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  have h_mem_rec := h_mem,
  unpack_memory code_verify_zero at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33⟩,
  -- ap += 1
  step_advance_ap hpc0 hpc1,
  -- local var
  mkdef lc_q : q = (mem (σ.fp)),
  -- function call
  step_assert_eq hpc2 with arg0,
  step_assert_eq hpc3 hpc4 with arg1,
  step_sub hpc5 (auto_sound_assert_165_bit mem _ range_check_ptr (q + 2 ^ 164) _ _ _),
  { rw hpc6, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q] },
    try { dsimp [cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q] },
    try { dsimp [cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call7 ap7 h_call7,
  rcases h_call7 with ⟨h_call7_ap_offset, h_call7⟩,
  rcases h_call7 with ⟨rc_m7, rc_mle7, hl_range_check_ptr₁, h_call7⟩,
  mkdef htv_range_check_ptr₁ : range_check_ptr₁ = (mem (ap7 - 1)),
  simp only [←htv_range_check_ptr₁] at h_call7,
  try { simp only [arg0 ,arg1] at hl_range_check_ptr₁ },
  try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₁ }, try { rw [←hin_range_check_ptr] at hl_range_check_ptr₁ },
  try { simp only [arg0 ,arg1] at h_call7 },
  rw [hin_range_check_ptr] at h_call7,
  clear arg0 arg1,
  -- tempvar
  step_assert_eq hpc7 with tv_r10,
  step_assert_eq hpc8 hpc9 with tv_r11,
  mkdef hl_r1 : r1 = ((val.d0 + q * SECP_REM0) / (BASE : ℤ) : F),
  have htv_r1: r1 = _, {
    have h_δ7_c0 : ∀ x : F, x / (BASE : ℤ) = x * (-46768052394588894761721767695234645457402928824320 : ℤ),
    { intro x,  apply div_eq_mul_inv', apply PRIME.int_cast_mul_eq_one, rw [PRIME], try { simp_int_casts }, norm_num1 },
    apply eq.symm, apply eq.trans tv_r11,
      try { simp only [h_δ7_c0] at hl_r1 },
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1] },
      try { dsimp [cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [tv_r10] },
      try { simp only [h_call7_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_r10 tv_r11,
  try { dsimp at hl_r1 }, try { arith_simps at hl_r1 },
  -- function call
  step_assert_eq hpc10 with arg0,
  step_assert_eq hpc11 hpc12 with arg1,
  step_sub hpc13 (auto_sound_assert_165_bit mem _ range_check_ptr₁ (r1 + 2 ^ 164) _ _ _),
  { rw hpc14, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1, htv_r1] },
    try { dsimp [cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { simp only [h_call7_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1, htv_r1] },
    try { dsimp [cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { simp only [h_call7_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call15 ap15 h_call15,
  rcases h_call15 with ⟨h_call15_ap_offset, h_call15⟩,
  rcases h_call15 with ⟨rc_m15, rc_mle15, hl_range_check_ptr₂, h_call15⟩,
  mkdef htv_range_check_ptr₂ : range_check_ptr₂ = (mem (ap15 - 1)),
  simp only [←htv_range_check_ptr₂] at h_call15,
  try { simp only [arg0 ,arg1] at hl_range_check_ptr₂ },
  try { rw [←htv_range_check_ptr₂] at hl_range_check_ptr₂ }, try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₂ },
  try { simp only [arg0 ,arg1] at h_call15 },
  rw [←htv_range_check_ptr₁, hl_range_check_ptr₁, hin_range_check_ptr] at h_call15,
  clear arg0 arg1,
  -- tempvar
  step_assert_eq hpc15 hpc16 with tv_r20,
  step_assert_eq hpc17 with tv_r21,
  step_assert_eq hpc18 with tv_r22,
  step_assert_eq hpc19 hpc20 with tv_r23,
  mkdef hl_r2 : r2 = ((val.d1 + q * SECP_REM1 + r1) / (BASE : ℤ) : F),
  have htv_r2: r2 = _, {
    have h_δ15_c0 : ∀ x : F, x / (BASE : ℤ) = x * (-46768052394588894761721767695234645457402928824320 : ℤ),
    { intro x,  apply div_eq_mul_inv', apply PRIME.int_cast_mul_eq_one, rw [PRIME], try { simp_int_casts }, norm_num1 },
    apply eq.symm, apply eq.trans tv_r23,
      try { simp only [h_δ15_c0] at hl_r2 },
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1, htv_r1, htv_range_check_ptr₂, hl_r2] },
      try { dsimp [cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [tv_r20, tv_r21, tv_r22] },
      try { simp only [h_call7_ap_offset, h_call15_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear tv_r20 tv_r21 tv_r22 tv_r23,
  try { dsimp at hl_r2 }, try { arith_simps at hl_r2 },
  -- function call
  step_assert_eq hpc21 with arg0,
  step_assert_eq hpc22 hpc23 with arg1,
  step_sub hpc24 (auto_sound_assert_165_bit mem _ range_check_ptr₂ (r2 + 2 ^ 164) _ _ _),
  { rw hpc25, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1, htv_r1, htv_range_check_ptr₂, hl_r2, htv_r2] },
    try { dsimp [cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { simp only [h_call7_ap_offset, h_call15_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1, htv_r1, htv_range_check_ptr₂, hl_r2, htv_r2] },
    try { dsimp [cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1] },
    try { simp only [h_call7_ap_offset, h_call15_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call26 ap26 h_call26,
  rcases h_call26 with ⟨h_call26_ap_offset, h_call26⟩,
  rcases h_call26 with ⟨rc_m26, rc_mle26, hl_range_check_ptr₃, h_call26⟩,
  mkdef htv_range_check_ptr₃ : range_check_ptr₃ = (mem (ap26 - 1)),
  simp only [←htv_range_check_ptr₃] at h_call26,
  try { simp only [arg0 ,arg1] at hl_range_check_ptr₃ },
  try { rw [←htv_range_check_ptr₃] at hl_range_check_ptr₃ }, try { rw [←htv_range_check_ptr₂] at hl_range_check_ptr₃ },
  try { simp only [arg0 ,arg1] at h_call26 },
  rw [←htv_range_check_ptr₂, hl_range_check_ptr₂, hl_range_check_ptr₁, hin_range_check_ptr] at h_call26,
  clear arg0 arg1,
  -- compound assert eq
  have h_δ26_c0 : ((BASE : ℤ) / (4 : ℤ) : F) = (19342813113834066795298816 : ℤ),
  { apply PRIME.div_eq_const,
    { apply PRIME.cast_ne_zero, norm_num1, rw [PRIME], try { simp_int_casts }, norm_num1 },
    rw [PRIME], try { simp_int_casts }, norm_num1 },
  step_assert_eq hpc26 hpc27 with temp0,
  step_assert_eq hpc28 hpc29 with temp1,
  step_assert_eq hpc30 with temp2,
  step_assert_eq hpc31 with temp3,
  have a26: val.d2 + q * SECP_REM2 = q * ((BASE : ℤ) / (4 : ℤ)) - r2, {
    try { simp only [h_δ26_c0] },
    apply assert_eq_reduction temp3.symm,
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1, htv_r1, htv_range_check_ptr₂, hl_r2, htv_r2, htv_range_check_ptr₃] },
    try { dsimp [cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [temp0, temp1, (eq_sub_of_eq_add temp2)] },
    try { simp only [h_call7_ap_offset, h_call15_ap_offset, h_call26_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
  },
  try { dsimp at a26 }, try { arith_simps at a26 },
  clear temp0 temp1 temp2 temp3,
  -- return
  step_assert_eq hpc32 with hret0,
  step_ret hpc33,
  -- finish
  step_done, use_only [rfl, rfl],
  split,
  { try { simp only [h_call7_ap_offset ,h_call15_ap_offset ,h_call26_ap_offset] },
    try { arith_simps }, try { refl } },
  -- range check condition
  use_only (rc_m7+rc_m15+rc_m26+0+0), split,
  linarith [rc_mle7, rc_mle15, rc_mle26],
  split,
  { try { norm_num1 }, arith_simps, try { simp only [hret0] },
    try { rw [←htv_range_check_ptr₃] }, try { rw [hl_range_check_ptr₃] }, try { rw [←htv_range_check_ptr₂] }, try { rw [hl_range_check_ptr₂] }, try { rw [←htv_range_check_ptr₁] }, try { rw [hl_range_check_ptr₁] }, try { rw [hin_range_check_ptr] },
    try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
  intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
  have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
  -- Final Proof
  -- user-provided reduction
  suffices auto_spec: auto_spec_verify_zero mem _ range_check_ptr val _,
  { apply sound_verify_zero, apply auto_spec },
  -- prove the auto generated assertion
  dsimp [auto_spec_verify_zero],
  try { norm_num1 }, try { arith_simps },
  use_only [q],
  use_only [κ_call7],
  use_only [range_check_ptr₁],
  have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
  have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
  have spec7 := h_call7 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at spec7 }, try { rw [←htv_range_check_ptr₁] at spec7 },
  try { dsimp at spec7, arith_simps at spec7 },
  use_only [spec7],
  use_only [r1, hl_r1],
  try { dsimp }, try { arith_simps },
  use_only [κ_call15],
  use_only [range_check_ptr₂],
  have rc_h_range_check_ptr₂ := range_checked_offset' rc_h_range_check_ptr₁,
  have rc_h_range_check_ptr₂' := range_checked_add_right rc_h_range_check_ptr₂, try { norm_cast at rc_h_range_check_ptr₂' },
  have spec15 := h_call15 rc_h_range_check_ptr₁',
    try { rw [←hin_range_check_ptr] at spec15 }, try { rw [←hl_range_check_ptr₁] at spec15 }, try { rw [←htv_range_check_ptr₂] at spec15 },
  try { dsimp at spec15, arith_simps at spec15 },
  use_only [spec15],
  use_only [r2, hl_r2],
  try { dsimp }, try { arith_simps },
  use_only [κ_call26],
  use_only [range_check_ptr₃],
  have rc_h_range_check_ptr₃ := range_checked_offset' rc_h_range_check_ptr₂,
  have rc_h_range_check_ptr₃' := range_checked_add_right rc_h_range_check_ptr₃, try { norm_cast at rc_h_range_check_ptr₃' },
  have spec26 := h_call26 rc_h_range_check_ptr₂',
    try { rw [←hin_range_check_ptr] at spec26 }, try { rw [←hl_range_check_ptr₁] at spec26 }, try { rw [←hl_range_check_ptr₂] at spec26 }, try { rw [←htv_range_check_ptr₃] at spec26 },
  try { dsimp at spec26, arith_simps at spec26 },
  use_only [spec26],
  use_only [a26],
  try { split, trivial <|> linarith },
  try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_val, lc_q, htv_range_check_ptr₁, hl_r1, htv_r1, htv_range_check_ptr₂, hl_r2, htv_r2, htv_range_check_ptr₃] }, },
  try { dsimp [cast_UnreducedBigInt3] },
  try { arith_simps }, try { simp only [hret0] },
  try { simp only [h_call7_ap_offset, h_call15_ap_offset, h_call26_ap_offset] },
  try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
end

