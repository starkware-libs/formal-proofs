/-
This is the final correctenss theorem, stated in terms of the autogenerated constraints.

The statements of theorems only depend on the data and constraints specified in
`constraints_autogenerated.lean` and the machine semantics in `cpu.lean`.
-/
import starkware.cairo.lean.semantics.air_encoding.correctness
import starkware.cairo.lean.semantics.air_encoding.glue

noncomputable theory
open_locale classical
open_locale big_operators

variables {F : Type} [field F] [fintype F]

/-
These are the constraints that the verifier has to check against the public data.
-/

structure public_constraints (inp : input_data F) (pd : public_data F) : Prop :=
(h_mem_star :
  let z     := pd.memory__multi_column_perm__perm__interaction_elm,
      alpha := pd.memory__multi_column_perm__hash_interaction_elm0,
      p     := pd.memory__multi_column_perm__perm__public_memory_prod,
      dom_m_star := { x // option.is_some (inp.m_star x) } in
    p * ∏ a : dom_m_star, (z - (a.val + alpha * mem_val a)) = z^(fintype.card dom_m_star))
(h_card_dom : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
(public_memory_prod_eq_one : pd.rc16__perm__public_memory_prod = 1)
(rc_max_lt : pd.rc_max < 2^16)
(rc_min_le : pd.rc_min ≤ pd.rc_max)
(trace_length_le_char : inp.trace_length ≤ ring_char F)

/-
The main correctness theorem.
-/

theorem final_correctness
    (char_ge : ring_char F ≥ 2^63)
    /- public data -/
    (inp     : input_data F)
    (pd      : public_data F)
    (pc      : public_constraints inp pd)
    (c       : columns F) :
    /- sets to avoid -/
  ∃ bad1
    bad2
    bad3     : finset F,
    bad1.card ≤ (inp.trace_length / 2)^2 ∧
    bad2.card ≤ inp.trace_length / 2 ∧
    bad3.card ≤ inp.trace_length ∧
  ∀ ci       : columns_inter F,
      /- autogenerated constraints-/
      cpu__decode c ∧
      cpu__operands c ∧
      cpu__update_registers inp c ∧
      cpu__opcodes c ∧
      memory inp pd c ci ∧
      rc16 inp pd c ci ∧
      public_memory c ∧
      rc_builtin inp pd c ∧
      toplevel_constraints inp c ∧
      /- probabilistic constraints -/
      pd.memory__multi_column_perm__hash_interaction_elm0 ∉ bad1 ∧
      pd.memory__multi_column_perm__perm__interaction_elm ∉ bad2 ∧
      pd.memory__multi_column_perm__perm__interaction_elm ≠ 0 ∧
      pd.rc16__perm__interaction_elm ∉ bad3 →
      let -- number of execution steps
          T := inp.trace_length / 16 - 1,
          -- memory elements checked by range check builtin
          rc_len := inp.trace_length / 128 in
      /- the conclusion -/
      ∃ mem : F → F,
        option.fn_extends mem inp.m_star ∧
        (∀ i < rc_len, ∃ n < 2^128, mem (pd.initial_rc_addr + i) = ↑n) ∧
        ∃ exec : fin (T + 1) → register_state F,
          (exec 0).pc = inp.initial_pc ∧
          (exec 0).ap = inp.initial_ap ∧
          (exec 0).fp = inp.initial_ap ∧
          (exec (fin.last T)).pc = inp.final_pc ∧
          (exec (fin.last T)).ap = inp.final_ap ∧
          ∀ i : fin T, next_state mem (exec i.cast_succ) (exec i.succ) :=
begin
  use bad1 pc.h_card_dom c.column19 c.column20,
  use bad2 pd pc.h_card_dom c.column19 c.column20,
  use bad3 inp c.column0 c.column2,
  use bad1_bound pc.h_card_dom _ _,
  use bad2_bound pd pc.h_card_dom _ _,
  use bad3_bound pc.h_card_dom _ _,
  intro ci,
  rintros ⟨cd, ops, upd, opcodes, m, rc, pm, rcb, iandf, prob1, prob2, prob3, prob4⟩,
  dsimp,
  exact execution_exists char_ge
    (inp.to_input_data_aux pd pc.rc_max_lt pc.rc_min_le)
    (to_constraints cd ops upd opcodes m rc pm rcb iandf pc.h_mem_star pc.h_card_dom
      pc.public_memory_prod_eq_one pc.rc_max_lt pc.rc_min_le pc.trace_length_le_char)
    { hprob₁ := prob1,
      hprob₂ := prob2,
      hprob₃ := prob3,
      hprob₄ := prob4 }
end
