/-
File: math_spec.lean

Modified version of the autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.prelude
import tactic.polyrith

import starkware.cairo.common.bool_spec

open starkware.cairo.common.bool
open_locale big_operators
namespace starkware.cairo.common.math

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]

-- End of automatically generated prelude.

namespace assert_le_felt

@[reducible] def PRIME_OVER_3_HIGH := 3544607988759775765608368578435044694
@[reducible] def PRIME_OVER_2_HIGH := 5316911983139663648412552867652567041

end assert_le_felt

namespace split_felt

@[reducible] def MAX_HIGH := (((-1)) : ℤ) / (2 ^ 128 : ℤ)
@[reducible] def MAX_LOW := 0

end split_felt

namespace assert_250_bit

@[reducible] def UPPER_BOUND := 2 ^ 250
@[reducible] def SHIFT := 2 ^ 128
@[reducible] def HIGH_BOUND := (UPPER_BOUND : ℤ) / (SHIFT : ℤ)

end assert_250_bit

namespace starkware.cairo.common.math.assert_250_bit

@[reducible] def UPPER_BOUND := 2 ^ 250
@[reducible] def SHIFT := 2 ^ 128
@[reducible] def HIGH_BOUND := (UPPER_BOUND : ℤ) / (SHIFT : ℤ)

end starkware.cairo.common.math.assert_250_bit

namespace starkware.cairo.common.math.split_felt

@[reducible] def MAX_HIGH := ((-1) : ℤ) / (2 ^ 128 : ℤ)
@[reducible] def MAX_LOW := 0

end starkware.cairo.common.math.split_felt

/-
Constants and calculations
-/

def UPPER_BOUND := 2^250
def HIGH_PART_SHIFT := 2^250 / 2^128
def MAX_HIGH := (PRIME - 1) / 2^128
def MAX_LOW := (PRIME - 1) % 2^128
def CUTOFF := 2^128

theorem UPPER_BOUND_eq : UPPER_BOUND =
  1809251394333065553493296640760748560207343510400633813116524750123642650624 :=
by unfold UPPER_BOUND; norm_num1

theorem HIGH_PART_SHIFT_eq : HIGH_PART_SHIFT = 5316911983139663491615228241121378304 :=
by unfold HIGH_PART_SHIFT; norm_num1

theorem MAX_HIGH_eq : MAX_HIGH = 10633823966279327296825105735305134080 :=
by unfold MAX_HIGH; unfold PRIME; norm_num1

theorem MAX_LOW_eq : MAX_LOW = 0 :=
by unfold MAX_LOW; unfold PRIME; norm_num1

theorem CUTOFF_eq : CUTOFF = 340282366920938463463374607431768211456 :=
by unfold CUTOFF; norm_num1

lemma rc_bound_le_CUTOFF : rc_bound F ≤ CUTOFF := rc_bound_hyp F

/-
Specifications for all the functions.
-/

def spec_assert_not_zero (mem : F → F) (κ : ℕ) (value : F) : Prop :=
  value ≠ 0

def spec_assert_not_equal (mem : F → F) (κ : ℕ) (a b : F) : Prop :=
  a ≠ b

def spec_assert_nn (mem : F → F) (κ : ℕ) (range_check_ptr a ρ_range_check_ptr : F) : Prop :=
  ∃ n : ℕ, n < rc_bound F ∧ a = ↑n

def spec_assert_le (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ n : ℕ, n < rc_bound F ∧ b = a + ↑n

def spec_assert_lt (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ n : ℕ, n < rc_bound F ∧ b = a + ↑(n + 1)

def spec_assert_nn_le (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ m n : ℕ, m < rc_bound F ∧ n < rc_bound F ∧ a = ↑m ∧ b = ↑(m + n)

def spec_assert_in_range (mem : F → F) (κ : ℕ) (range_check_ptr value lower upper ρ_range_check_ptr : F) : Prop :=
  ∃ m n : ℕ, m < rc_bound F ∧ n < rc_bound F ∧ value = lower + ↑m ∧ upper = value + ↑(n + 1)

def spec_assert_le_250_bit (mem : F → F) (range_check_ptr a b ret0 : F) : Prop :=
   ∃ n : ℕ, n < rc_bound F * HIGH_PART_SHIFT + rc_bound F ∧ b = a + ↑n

def spec_split_felt (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ_high ρ_low : F) : Prop :=
∃ hi lo : ℕ, hi < rc_bound F ∧ lo < rc_bound F  ∧
  ρ_high = ↑hi ∧ ρ_low = ↑lo ∧ value = ↑(hi * CUTOFF + lo) ∧ hi * CUTOFF + lo < PRIME

def spec_assert_le_felt (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ m n : ℕ, m < PRIME ∧ n < PRIME ∧ a = ↑m ∧ b = ↑n ∧ m ≤ n

def spec_assert_lt_felt (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
    ∃ m n : ℕ, m < PRIME ∧ n < PRIME ∧ a = ↑m ∧ b = ↑n ∧ m < n

def spec_abs_value (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ : F) : Prop :=
  ∃ n : ℕ, n < rc_bound F ∧ ρ = ↑n ∧ (ρ = value ∨ ρ = -value)

def spec_sign (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ : F) : Prop :=
  (value = 0 ∧ ρ = 0) ∨
  (value ≠ 0 ∧ (∃ n : ℕ, n < rc_bound F ∧ ((value = -↑n ∧ ρ = -1) ∨ (value = ↑n ∧ ρ = 1))))

def spec_unsigned_div_rem (mem : F → F) (κ : ℕ) (range_check_ptr value div ρ_range_check_ptr ρ_q ρ_r : F) : Prop :=
  ∃ q r n : ℕ, q < rc_bound F ∧ r < rc_bound F ∧ n < rc_bound F ∧
    value = ↑q * div + ↑r ∧ div = r + ↑(n + 1) ∧ ρ_q = q ∧ ρ_r = r

def spec_signed_div_rem (mem : F → F) (κ : ℕ) (range_check_ptr value div bound ρ_range_check_ptr ρ_q ρ_r : F) : Prop :=
  ∃ biased_q r n m : ℕ, ∃ q: F, biased_q < rc_bound F ∧ r < rc_bound F ∧ n < rc_bound F ∧ m < rc_bound F ∧
    q = ↑biased_q - bound ∧ value = q * div + ↑r ∧
    div = r + ↑(n + 1) ∧ 2 * bound = ↑biased_q + ↑(m + 1) ∧
    ρ_q = q ∧ ρ_r = r

def spec_split_int (mem : F → F) (κ : ℕ) (range_check_ptr value n base bound output ρ_range_check_ptr : F) : Prop :=
  base ≠ 0 →
    ∃ (nn < ring_char F),
      n = ↑nn ∧
      value = ∑ i in (finset.range nn), (mem (output + i) * base ^ i) ∧
      (0 < nn →
        ∃ bound_n < 2 * rc_bound F, bound = ↑bound_n ∧
        ∀ i < nn, ∃ m : ℕ, mem (output + i) = ↑m ∧ m < bound_n ∧ m ≤ rc_bound F)


def spec_sqrt (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ : F) : Prop :=
  ∃ (r < rc_bound F) (n < 2 ^ 250), ρ = ↑r ∧ value = ↑n ∧ r = nat.sqrt n

def spec_horner_eval (mem : F → F) (κ : ℕ) (n_coefficients coefficients point ρ_res : F) : Prop :=
  ∃ (n : ℕ), n < ring_char F ∧ n_coefficients = ↑n ∧
    ρ_res = ∑ i in (finset.range n), (mem (coefficients + i) * point ^ i)

/-
-- Auxiliary lemmas
-/

lemma le_of_le_rc_bound {n : ℕ} (h : n ≤ rc_bound F) : n ≤ 2 ^ 128 := le_trans h (rc_bound_hyp F)
lemma lt_of_lt_rc_bound {n : ℕ} (h : n < rc_bound F) : n < 2 ^ 128 := lt_of_lt_of_le h (rc_bound_hyp F)

/-
-- Function: assert_not_zero
-/

/- assert_not_zero autogenerated specification -/

def auto_spec_assert_not_zero_block3 (mem : F → F) (κ : ℕ) (value : F) : Prop :=
  1 ≤ κ

def auto_spec_assert_not_zero (mem : F → F) (κ : ℕ) (value : F) : Prop :=
  ((value = 0 ∧
    value = 1 ∧
    ∃ (κ₁ : ℕ), auto_spec_assert_not_zero_block3 mem κ₁ value ∧
    κ₁ + 2 ≤ κ) ∨
   (value ≠ 0 ∧
    ∃ (κ₁ : ℕ), auto_spec_assert_not_zero_block3 mem κ₁ value ∧
    κ₁ + 1 ≤ κ))

/- assert_not_zero soundness theorem -/

theorem sound_assert_not_zero
    {mem : F → F}
    (κ : ℕ)
    (value : F)
    (h_auto : auto_spec_assert_not_zero mem κ value) :
  spec_assert_not_zero mem κ value :=
begin
  rcases h_auto with (⟨h0, h1⟩ | ⟨h, _⟩),
  { exfalso, rw h0 at h1, apply zero_ne_one h1.left },
  use h
end

/-
-- Function: assert_not_equal
-/

/- assert_not_equal autogenerated specification -/

def auto_spec_assert_not_equal_block3 (mem : F → F) (κ : ℕ) (a b : F) : Prop :=
  1 ≤ κ

def auto_spec_assert_not_equal (mem : F → F) (κ : ℕ) (a b : F) : Prop :=
  ((a = b ∧
    a = a + 1 ∧
    ∃ (κ₁ : ℕ), auto_spec_assert_not_equal_block3 mem κ₁ a b ∧
    κ₁ + 3 ≤ κ) ∨
   (a ≠ b ∧
    ∃ (κ₁ : ℕ), auto_spec_assert_not_equal_block3 mem κ₁ a b ∧
    κ₁ + 2 ≤ κ))

/- assert_not_equal soundness theorem -/

theorem sound_assert_not_equal
    {mem : F → F}
    (κ : ℕ)
    (a b : F)
    (h_auto : auto_spec_assert_not_equal mem κ a b) :
  spec_assert_not_equal mem κ a b :=
begin
  rcases h_auto with (⟨h0, h1⟩ | ⟨h, _⟩),
  { exfalso, apply @zero_ne_one F, rw [←sub_eq_of_eq_add' h1.left, sub_self] },
  use h
end

/-
-- Function: assert_nn
-/

/- assert_nn autogenerated specification -/

def auto_spec_assert_nn (mem : F → F) (κ : ℕ) (range_check_ptr a ρ_range_check_ptr : F) : Prop :=
  a = mem range_check_ptr ∧
  is_range_checked (rc_bound F) (a) ∧
  ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 1 ∧
  3 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₁

/- assert_nn soundness theorem -/

theorem sound_assert_nn
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr a ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_nn mem κ range_check_ptr a ρ_range_check_ptr) :
  spec_assert_nn mem κ range_check_ptr a ρ_range_check_ptr :=
begin
  exact h_auto.2.1
end

/-
-- Function: assert_le
-/

/- assert_le autogenerated specification -/

def auto_spec_assert_le (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ (κ₁ : ℕ) (range_check_ptr₁ : F), spec_assert_nn mem κ₁ range_check_ptr (b - a) range_check_ptr₁ ∧
  κ₁ + 4 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₁

/- assert_le soundness theorem -/

theorem sound_assert_le
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr a b ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_le mem κ range_check_ptr a b ρ_range_check_ptr) :
  spec_assert_le mem κ range_check_ptr a b ρ_range_check_ptr :=
begin
  rcases h_auto with ⟨_, _, nn_b_sub_a, _⟩,
  rcases nn_b_sub_a with ⟨n, nlt, neq⟩,
  exact ⟨n, nlt, eq_add_of_sub_eq' neq⟩
end

/-
-- Function: assert_lt
-/

/- assert_lt autogenerated specification -/

def auto_spec_assert_lt (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ (κ₁ : ℕ) (range_check_ptr₁ : F), spec_assert_le mem κ₁ range_check_ptr a (b - 1) range_check_ptr₁ ∧
  κ₁ + 5 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₁

/- assert_lt soundness theorem -/

theorem sound_assert_lt
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr a b ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_lt mem κ range_check_ptr a b ρ_range_check_ptr) :
  spec_assert_lt mem κ range_check_ptr a b ρ_range_check_ptr :=
begin
  rcases h_auto with ⟨_, _, nn_b_sub_a, _⟩,
  rcases nn_b_sub_a with ⟨n, nlt, neq⟩,
  use [n, nlt],
  rw [eq_add_of_sub_eq' neq, nat.cast_add, nat.cast_one, add_comm, add_assoc]
end

/-
-- Function: assert_nn_le
-/

/- assert_nn_le autogenerated specification -/

def auto_spec_assert_nn_le (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ (κ₁ : ℕ) (range_check_ptr₁ : F), spec_assert_nn mem κ₁ range_check_ptr a range_check_ptr₁ ∧
  ∃ (κ₂ : ℕ) (range_check_ptr₂ : F), spec_assert_le mem κ₂ range_check_ptr₁ a b range_check_ptr₂ ∧
  κ₁ + κ₂ + 7 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₂

/- assert_nn_le soundness theorem -/

theorem sound_assert_nn_le
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr a b ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_nn_le mem κ range_check_ptr a b ρ_range_check_ptr) :
  spec_assert_nn_le mem κ range_check_ptr a b ρ_range_check_ptr :=
begin
  rcases h_auto with ⟨_, _, nn_a, _, _, le_ab, _⟩,
  rcases nn_a with ⟨m, mlt, aeq⟩,
  rcases le_ab with ⟨n, nlt, abeq⟩,
  use [m, n, mlt, nlt, aeq],
  rw [abeq, aeq, nat.cast_add]
end

/-
-- Function: assert_in_range
-/

/- assert_in_range autogenerated specification -/

def auto_spec_assert_in_range (mem : F → F) (κ : ℕ) (range_check_ptr value lower upper ρ_range_check_ptr : F) : Prop :=
  ∃ (κ₁ : ℕ) (range_check_ptr₁ : F), spec_assert_le mem κ₁ range_check_ptr lower value range_check_ptr₁ ∧
  ∃ (κ₂ : ℕ) (range_check_ptr₂ : F), spec_assert_le mem κ₂ range_check_ptr₁ value (upper - 1) range_check_ptr₂ ∧
  κ₁ + κ₂ + 8 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₂

/- assert_in_range soundness theorem -/

theorem sound_assert_in_range
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value lower upper ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_in_range mem κ range_check_ptr value lower upper ρ_range_check_ptr) :
  spec_assert_in_range mem κ range_check_ptr value lower upper ρ_range_check_ptr :=
begin
  rcases h_auto with ⟨_, _, lower_le, _, _, value_le, _⟩,
  rcases lower_le with ⟨m, mlt, eq1⟩,
  rcases value_le with ⟨n, nlt, eq2⟩,
  use [m, n, mlt, nlt, eq1],
  rw [eq_add_of_sub_eq' eq2, nat.cast_add, nat.cast_one, add_comm, add_assoc]
end

/-
-- Function: assert_le_250_bit
-/

/- assert_le_250_bit autogenerated specification -/

def auto_spec_assert_le_250_bit (mem : F → F) (range_check_ptr a b ret0 : F) : Prop :=
  ∃ low : F, low = mem (range_check_ptr) ∧
  is_range_checked (rc_bound F) low ∧
  ∃ high : F, high = mem (range_check_ptr + 1) ∧
  is_range_checked (rc_bound F) high ∧
  ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 2 ∧
  ∃ UPPER_BOUND : F, UPPER_BOUND = 1809251394333065553493296640760748560207343510400633813116524750123642650624 ∧
  ∃ HIGH_PART_SHIFT : F, HIGH_PART_SHIFT = 5316911983139663491615228241121378304 ∧
  ∃ diff : F, diff = b - a ∧
  diff = high * HIGH_PART_SHIFT + low ∧
  ret0 = range_check_ptr₁

/- assert_le_250_bit soundness theorem -/

theorem sound_assert_le_250_bit
    {mem : F → F}
    (range_check_ptr a b ret0 : F)
    (h_auto : auto_spec_assert_le_250_bit mem range_check_ptr a b ret0) :
  spec_assert_le_250_bit mem range_check_ptr a b ret0 :=
begin
  rcases h_auto with ⟨low, _, rc_low, high, _, rc_high, _, _, _, _, H, rfl, diff, diffeq, diffeq2, _⟩,
  rcases rc_high with ⟨m, mlt, rfl⟩,
  rcases rc_low with ⟨n, nlt, rfl⟩,
  use [m * HIGH_PART_SHIFT + n], split,
  exact add_lt_add_of_le_of_lt (nat.mul_le_mul_right _ (le_of_lt mlt)) nlt,
  rw [eq_add_of_sub_eq diffeq.symm, add_comm diff, diffeq2, HIGH_PART_SHIFT_eq],
  rw [nat.cast_add, nat.cast_mul], simp only [nat.cast_bit0, nat.cast_one]
end

/-
-- Function: assert_250_bit
-/

/- assert_250_bit autogenerated specification -/

def auto_spec_assert_250_bit (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr : F) : Prop :=
  ∃ UPPER_BOUND : F, UPPER_BOUND = 1809251394333065553493296640760748560207343510400633813116524750123642650624 ∧
  ∃ SHIFT : F, SHIFT = 340282366920938463463374607431768211456 ∧
  ∃ HIGH_BOUND : F, HIGH_BOUND = 5316911983139663491615228241121378304 ∧
  ∃ low : F, low = mem range_check_ptr ∧
  is_range_checked (rc_bound F) low ∧
  ∃ high : F, high = mem (range_check_ptr + 1) ∧
  is_range_checked (rc_bound F) high ∧
  mem (range_check_ptr + 2) = HIGH_BOUND - 1 - high ∧
  is_range_checked (rc_bound F) (HIGH_BOUND - 1 - high) ∧
  value = high * SHIFT + low ∧
  ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 3 ∧
  10 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₁

def spec_assert_250_bit (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr : F) : Prop :=
  auto_spec_assert_250_bit mem κ range_check_ptr value ρ_range_check_ptr

/- assert_250_bit soundness theorem -/

theorem sound_assert_250_bit
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_250_bit mem κ range_check_ptr value ρ_range_check_ptr) :
  spec_assert_250_bit mem κ range_check_ptr value ρ_range_check_ptr :=
begin
  exact h_auto
end

/-
-- Function: split_felt
-/

/- split_felt autogenerated specification -/

def auto_spec_split_felt_block11 (mem : F → F) (κ : ℕ) (range_check_ptr value low high ρ_range_check_ptr ρ_high ρ_low : F) : Prop :=
  3 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr ∧
  ρ_high = high ∧
  ρ_low = low

def auto_spec_split_felt (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ_high ρ_low : F) : Prop :=
  ∃ MAX_HIGH : F, MAX_HIGH = 10633823966279327296825105735305134080 ∧
  ∃ MAX_LOW : F, MAX_LOW = 0 ∧
  ∃ low : F, low = mem range_check_ptr ∧
  is_range_checked (rc_bound F) low ∧
  ∃ high : F, high = mem (range_check_ptr + 1) ∧
  is_range_checked (rc_bound F) high ∧
  ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 2 ∧
  value = high * (2 ^ 128) + low ∧
  ((high = MAX_HIGH ∧
    ∃ (κ₁ : ℕ) (range_check_ptr₂ : F), spec_assert_le mem κ₁ range_check_ptr₁ low MAX_LOW range_check_ptr₂ ∧
    ∃ (κ₂ : ℕ), auto_spec_split_felt_block11 mem κ₂ range_check_ptr₂ value low high ρ_range_check_ptr ρ_high ρ_low ∧
    κ₁ + κ₂ + 12 ≤ κ) ∨
   (high ≠ MAX_HIGH ∧
    ∃ (κ₁ : ℕ) (range_check_ptr₂ : F), spec_assert_le mem κ₁ range_check_ptr₁ high (MAX_HIGH - 1) range_check_ptr₂ ∧
    ∃ (κ₂ : ℕ), auto_spec_split_felt_block11 mem κ₂ range_check_ptr₂ value low high ρ_range_check_ptr ρ_high ρ_low ∧
    κ₁ + κ₂ + 11 ≤ κ))

/- split_felt soundness theorem -/

lemma split_felt_aux0 {hi lo : ℕ} (hhi : hi ≤ MAX_HIGH) (hlo : lo ≤ MAX_LOW) :
  hi * CUTOFF + lo < PRIME :=
begin
  apply (lt_of_le_of_lt (add_le_add (nat.mul_le_mul_right _ hhi) hlo)),
  rw [MAX_HIGH, MAX_LOW, CUTOFF, add_comm, mul_comm, nat.mod_add_div, PRIME],
  apply PRIME_sub_one_lt
end

lemma split_felt_aux1 {n : ℕ} (hn : n < rc_bound F) (h : (↑n : F) = MAX_HIGH) :
  n = MAX_HIGH :=
by { apply PRIME.nat_coe_field_inj _ _ h, { linarith [two_mul_rc_bound_lt_PRIME F] }, rw [MAX_HIGH_eq, PRIME]; norm_num1 }

lemma split_felt_aux2 {m n : ℕ} (hm : m < rc_bound F) (hn : n < rc_bound F)
    (h : (MAX_LOW : F) = m + n) :
  m ≤ MAX_LOW :=
begin
  apply le_trans (nat.le_add_right _ n) (le_of_eq _),
  rw ←nat.cast_add at h, symmetry,
  apply PRIME.nat_coe_field_inj _ _ h,
  { rw [MAX_LOW_eq, PRIME], norm_num1 },
  linarith [hm, hn, two_mul_rc_bound_lt_PRIME F]
end

lemma split_felt_aux3 {hi lo : ℕ} (hhi : hi < MAX_HIGH) (hlo : lo < rc_bound F) :
  hi * CUTOFF + lo < PRIME :=
begin
  have : hi * CUTOFF + lo < (hi + 1) * CUTOFF,
  { rw [add_mul, one_mul, CUTOFF], apply add_lt_add_left,
    exact lt_of_lt_of_le hlo (rc_bound_hyp F) },
  apply lt_of_lt_of_le this,
  transitivity (MAX_HIGH * CUTOFF),
  apply nat.mul_le_mul_right _ hhi,
  transitivity,
  apply nat.div_mul_le_self,
  apply (le_of_lt PRIME_sub_one_lt)
end

lemma split_felt_aux4 {hi n : ℕ} (hhi : hi < rc_bound F) (hn : n < rc_bound F)
    (h : (MAX_HIGH - 1 : F) = hi + n) :
  hi < MAX_HIGH :=
begin
  rw ←nat.cast_add at h,
  apply nat.lt_of_le_of_lt _ (nat.pred_lt (show MAX_HIGH ≠ 0, by { rw MAX_HIGH_eq, norm_num })), rw ←nat.sub_one,
  have : MAX_HIGH - 1 = hi + n,
  { rw [←nat.cast_one, ←nat.cast_sub] at h,
    apply PRIME.nat_coe_field_inj _ _ h,
    { rw [MAX_HIGH_eq, PRIME], norm_num1 },
    linarith [hhi, hn, two_mul_rc_bound_lt_PRIME F], rw [MAX_HIGH_eq], norm_num },
  rw this,
  apply nat.le_add_right
end

theorem sound_split_felt
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value ρ_range_check_ptr ρ_high ρ_low : F)
    (h_auto : auto_spec_split_felt mem κ range_check_ptr value ρ_range_check_ptr ρ_high ρ_low) :
  spec_split_felt mem κ range_check_ptr value ρ_range_check_ptr ρ_high ρ_low :=
begin
  rcases h_auto with ⟨H, rfl, L, rfl, low, _, rc_low, high, _, rc_high, _, _, val_eq, htemp⟩,
  rcases rc_high with ⟨hi, hilt, hieq⟩,
  rcases rc_low with ⟨lo, lolt, loeq⟩,
  rcases htemp with (⟨heq, _, _, hle, _, ⟨_, _, ret1eq, ret2eq⟩, _ ⟩ | ⟨hne, _, _, hle, _, ⟨_, _, ret1eq, ret2eq⟩, _⟩),
  { use [hi, lo, hilt, lolt, ret1eq.trans hieq, ret2eq.trans loeq],
    split,
    { rw [CUTOFF, val_eq, hieq, loeq], norm_cast },
    rcases hle with ⟨n, nlt, neq⟩,
    apply split_felt_aux0,
    apply le_of_eq, apply split_felt_aux1 hilt, rw [←hieq, heq, MAX_HIGH_eq],
    simp only [nat.cast_bit0, nat.cast_bit1, nat.cast_one],
    apply split_felt_aux2 lolt nlt,
    rw [MAX_LOW_eq, nat.cast_zero, neq, loeq] },
  use [hi, lo, hilt, lolt, ret1eq.trans hieq, ret2eq.trans loeq],
  split,
  { rw [CUTOFF, val_eq, hieq, loeq], norm_cast },
  rcases hle with ⟨n, nlt, neq⟩,
  apply split_felt_aux3 _ lolt,
  apply split_felt_aux4 hilt nlt,
  rw [←hieq, ←neq, MAX_HIGH_eq], simp only [nat.cast_bit0, nat.cast_bit1, nat.cast_one]
end

/-
-- Function: assert_le_felt
-/

/- assert_le_felt autogenerated specification -/

def auto_spec_assert_le_felt (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ PRIME_OVER_3_HIGH : F, PRIME_OVER_3_HIGH = 3544607988759775765608368578435044694 ∧
  ∃ PRIME_OVER_2_HIGH : F, PRIME_OVER_2_HIGH = 5316911983139663648412552867652567041 ∧
  ∃ arc_short : F, arc_short = mem range_check_ptr + mem (range_check_ptr + 1) * PRIME_OVER_3_HIGH ∧
  is_range_checked (rc_bound F) (mem range_check_ptr) ∧
  is_range_checked (rc_bound F) (mem (range_check_ptr + 1)) ∧
  ∃ arc_long : F, arc_long = mem (range_check_ptr + 2) + mem (range_check_ptr + 3) * PRIME_OVER_2_HIGH ∧
  is_range_checked (rc_bound F) (mem (range_check_ptr + 2)) ∧
  is_range_checked (rc_bound F) (mem (range_check_ptr + 3)) ∧
  ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 4 ∧
  ∃ arc_sum : F, arc_sum = arc_short + arc_long ∧
  ∃ arc_prod : F, arc_prod = arc_short * arc_long ∧
  ∃ anon_cond : F,
  ((anon_cond = 0 ∧
    arc_sum = ((-1)) - a ∧
    arc_prod = (a - b) * (1 + b) ∧
    18 ≤ κ ∧
    ρ_range_check_ptr = range_check_ptr₁) ∨
   (anon_cond ≠ 0 ∧
    ∃ anon_cond : F,
    ((anon_cond = 0 ∧
      ∃ m1mb : F, m1mb = ((-1)) - b ∧
      arc_sum = a + m1mb ∧
      arc_prod = a * m1mb ∧
      18 ≤ κ ∧
      ρ_range_check_ptr = range_check_ptr₁) ∨
     (anon_cond ≠ 0 ∧
      arc_sum = b ∧
      arc_prod = a * (b - a) ∧
      17 ≤ κ ∧
      ρ_range_check_ptr = range_check_ptr₁))))

/- assert_le_felt soundness theorem -/

lemma assert_le_felt_aux {hia loa hib lob : ℕ}
    (hlt : hia < hib) (hloa : loa < rc_bound F) :
  hia * CUTOFF + loa ≤ hib * CUTOFF + lob :=
have hrc : rc_bound F ≤ CUTOFF, by { rw [CUTOFF], apply rc_bound_hyp F},
calc
  hia * CUTOFF + loa ≤ (hia + 1) * CUTOFF :
    by { rw [add_mul, one_mul], apply add_le_add_left, linarith }
  ... ≤ hib * CUTOFF : by { apply nat.mul_le_mul_right, apply hlt }
  ... ≤ hib * CUTOFF + lob : nat.le_add_right _ _

theorem eq_of_sum_product_eq {F : Type*} [field F] {a b c d: F}
    (hsum : a + b = c + d) (hprod : a * b = c * d) :
  (a = c ∧ b = d) ∨ (a = d ∧ b = c) :=
begin
  have : (a - c) * (a - d) = 0,
  { transitivity (a * a - (c + d) * a + c * d),
    { ring },
    rw [←hsum, ←hprod], ring },
  rcases (eq_zero_or_eq_zero_of_mul_eq_zero this) with h | h,
  { left,
    rw sub_eq_zero at h,
    use h,
    rwa [h, add_left_cancel_iff] at hsum },
  right,
  rw sub_eq_zero at h,
  use h,
  rwa [h, add_comm, add_right_cancel_iff] at hsum
end

theorem sound_assert_le_felt
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr a b ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_le_felt mem κ range_check_ptr a b ρ_range_check_ptr) :
  spec_assert_le_felt mem κ range_check_ptr a b ρ_range_check_ptr :=
begin
  rcases h_auto with ⟨P3H, P3Heq, P2H, P2Heq, arc_short, arc_short_eq, hrc, hrc1, arc_long, arc_long_eq, hrc2, hrc3, _, _,
  arc_sum, arc_sum_eq, arc_prod, arc_prod_eq, _, hrest⟩,
  rcases hrc with ⟨n, nlt, neq⟩,
  rcases hrc1 with ⟨n1, n1lt, n1eq⟩,
  rcases hrc2 with ⟨n2, n2lt, n2eq⟩,
  rcases hrc3 with ⟨n3, n3lt, n3eq⟩,
  have arc_short_eq' : arc_short = ↑(n + n1 * assert_le_felt.PRIME_OVER_3_HIGH),
  { rw [assert_le_felt.PRIME_OVER_3_HIGH],
    simp only [nat.cast_add, nat.cast_mul, nat.cast_bit0, nat.cast_bit1, nat.cast_one, arc_short_eq, ←neq, ←n1eq, P3Heq] },
  generalize n_arc_short_eq : n + n1 * assert_le_felt.PRIME_OVER_3_HIGH =
    n_arc_short,
  have coe_n_arc_short_eq : ↑n_arc_short = arc_short,
  { rw [←n_arc_short_eq, arc_short_eq'] },
  have n_arc_short_le : n_arc_short ≤ 2^128 * (1 + assert_le_felt.PRIME_OVER_3_HIGH),
  { rw [mul_add, mul_one, ←n_arc_short_eq],
    apply add_le_add (le_of_lt (lt_of_lt_of_le nlt(rc_bound_hyp F))),
    apply nat.mul_le_mul_of_nonneg_right,
    exact le_of_lt (lt_of_lt_of_le n1lt(rc_bound_hyp F)) },
  have arc_long_eq' : arc_long = ↑(n2 + n3 * assert_le_felt.PRIME_OVER_2_HIGH),
  { rw [assert_le_felt.PRIME_OVER_2_HIGH],
    simp only [nat.cast_add, nat.cast_mul, nat.cast_bit0, nat.cast_bit1, nat.cast_one, arc_long_eq, ←n2eq, ←n3eq, P2Heq] },
  generalize n_arc_long_eq : n2 + n3 * assert_le_felt.PRIME_OVER_2_HIGH = n_arc_long,
  have coe_n_arc_long_eq : ↑n_arc_long = arc_long,
  { rw [←n_arc_long_eq, arc_long_eq'] },
  have n_arc_long_le : n_arc_long ≤ 2^128 * (1 + assert_le_felt.PRIME_OVER_2_HIGH),
  { rw [mul_add, mul_one, ←n_arc_long_eq],
    apply add_le_add (le_of_lt (lt_of_lt_of_le n2lt(rc_bound_hyp F))),
    apply nat.mul_le_mul_of_nonneg_right,
    exact le_of_lt (lt_of_lt_of_le n3lt(rc_bound_hyp F)) },
  have short_add_long_add_one_le_PRIME:
    n_arc_short + (n_arc_long + 1) ≤ PRIME,
  { refine le_trans (add_le_add n_arc_short_le (add_le_add_right n_arc_long_le _)) _,
    rw [assert_le_felt.PRIME_OVER_2_HIGH, assert_le_felt.PRIME_OVER_3_HIGH, PRIME],
    norm_num1 },
  have short_add_one_add_long_le_PRIME: (n_arc_short + 1) + n_arc_long ≤ PRIME,
  { rw [add_assoc, add_comm 1],
    exact short_add_long_add_one_le_PRIME },
  have long_add_one_le_PRIME: n_arc_long + 1 ≤ PRIME :=
    le_trans (nat.le_add_left _ _) short_add_long_add_one_le_PRIME,
  have short_add_one_le_PRIME: n_arc_short + 1 ≤ PRIME :=
    le_trans (nat.le_add_right _ _) short_add_one_add_long_le_PRIME,
  have long_le_PRIME: n_arc_long ≤ PRIME :=
    le_trans (nat.le_add_left _ _) short_add_one_add_long_le_PRIME,
  have short_le_PRIME: n_arc_short ≤ PRIME :=
    le_trans (nat.le_add_right _ _) short_add_long_add_one_le_PRIME,
  have long_lt_PRIME: n_arc_long < PRIME := nat.lt_of_succ_le long_add_one_le_PRIME,
  have short_lt_PRIME: n_arc_short < PRIME := nat.lt_of_succ_le short_add_one_le_PRIME,
  have short_add_long_lt_PRIME: n_arc_short + n_arc_long < PRIME :=
    nat.lt_of_succ_le short_add_long_add_one_le_PRIME,
  have coe_PRIME : (PRIME : F) = 0,
  { apply char_p.cast_eq_zero },
  rcases hrest with ⟨_, hcase1⟩ | ⟨_, ⟨_, ⟨_, hcase2⟩ | ⟨_, hcase3⟩⟩⟩,
  { rcases hcase1 with ⟨arc_sum_eq', arc_prod_eq', _, _⟩,
    have aux1 : b - a + (-1 - b) = arc_short + arc_long,
    { rw [←arc_sum_eq, arc_sum_eq'], ring },
    have aux2 : (b - a) * (-1 - b) = arc_short * arc_long,
    { rw [←arc_prod_eq, arc_prod_eq'], ring },
    rcases eq_of_sum_product_eq aux1 aux2 with ⟨h1, h2⟩ | ⟨h1, h2⟩,
    { use PRIME - (n_arc_short + (n_arc_long + 1)),
      use PRIME - (n_arc_long + 1),
      split,
      { apply nat.sub_lt PRIME_pos,
        apply add_pos_of_nonneg_of_pos (nat.zero_le _) (nat.succ_pos _) },
      split,
      { apply nat.sub_lt PRIME_pos,
        apply nat.succ_pos _ },
      split,
      { rw [nat.cast_sub], swap,
        { exact short_add_long_add_one_le_PRIME },
        rw [char_p.cast_eq_zero, zero_sub, nat.cast_add, nat.cast_add, nat.cast_one, coe_n_arc_short_eq, coe_n_arc_long_eq],
        linear_combination -aux1 },
      split,
      { rw [nat.cast_sub], swap,
        { exact long_add_one_le_PRIME },
        rw [char_p.cast_eq_zero, zero_sub, nat.cast_add, nat.cast_one, coe_n_arc_long_eq, neg_add],
        linear_combination -h2 },
      apply nat.sub_le_sub_left,
      apply nat.le_add_left },
    use PRIME - ((n_arc_short + 1) + n_arc_long),
    use PRIME - (n_arc_short + 1),
    split,
    { apply nat.sub_lt PRIME_pos,
      apply add_pos_of_pos_of_nonneg (nat.succ_pos _) (nat.zero_le _) },
    split,
    { apply nat.sub_lt PRIME_pos,
      apply nat.succ_pos _ },
    split,
    { rw [nat.cast_sub], swap,
      { exact short_add_one_add_long_le_PRIME },
      rw [char_p.cast_eq_zero, zero_sub, nat.cast_add, nat.cast_add, nat.cast_one, coe_n_arc_short_eq, coe_n_arc_long_eq],
      linear_combination -aux1 },
    split,
    { rw [nat.cast_sub], swap,
      { exact short_add_one_le_PRIME },
      rw [char_p.cast_eq_zero, zero_sub, nat.cast_add, nat.cast_one, coe_n_arc_short_eq, neg_add],
      linear_combination -h2 },
    apply nat.sub_le_sub_left,
    apply nat.le_add_right },
  { rcases hcase2 with ⟨_, rfl, arc_sum_eq', arc_prod_eq', _, _⟩,
    have aux1 : a + (-1 - b) = arc_short + arc_long,
    { rw [←arc_sum_eq, arc_sum_eq'] },
    have aux2 : a * (-1 - b) = arc_short * arc_long,
    { rw [←arc_prod_eq, arc_prod_eq'] },
    rcases eq_of_sum_product_eq aux1 aux2 with ⟨h1, h2⟩ | ⟨h1, h2⟩,
    { use n_arc_short,
      use PRIME - (n_arc_long + 1),
      split,
      { exact short_lt_PRIME },
      split,
      { apply nat.sub_lt PRIME_pos (nat.succ_pos _) },
      split,
      { rw [h1, coe_n_arc_short_eq] },
      split,
      { rw [nat.cast_sub], swap,
        { exact long_add_one_le_PRIME },
        rw [char_p.cast_eq_zero, zero_sub, nat.cast_add, nat.cast_one, coe_n_arc_long_eq],
        linear_combination -h2 },
      apply le_tsub_of_add_le_right,
      exact short_add_long_add_one_le_PRIME },
    use n_arc_long,
    use PRIME - (n_arc_short + 1),
    split,
    { exact long_lt_PRIME },
    split,
    { apply nat.sub_lt PRIME_pos (nat.succ_pos _) },
    split,
    { rw [h1, coe_n_arc_long_eq] },
    split,
    { rw [nat.cast_sub], swap,
      { exact short_add_one_le_PRIME },
      rw [char_p.cast_eq_zero, zero_sub, nat.cast_add, nat.cast_one, coe_n_arc_short_eq],
      linear_combination -h2 },
    apply le_tsub_of_add_le_right,
    rw add_comm,
    exact short_add_one_add_long_le_PRIME },
  { rcases hcase3 with ⟨arc_sum_eq', arc_prod_eq', _, _⟩,
    have aux1 : a + (b - a) = arc_short + arc_long,
    { rw [←arc_sum_eq, arc_sum_eq'], ring },
    have aux2 : a * (b - a) = arc_short * arc_long,
    { rw [←arc_prod_eq, arc_prod_eq'] },
    rcases eq_of_sum_product_eq aux1 aux2 with ⟨h1, h2⟩ | ⟨h1, h2⟩,
    { use n_arc_short,
      use n_arc_short + n_arc_long,
      use short_lt_PRIME,
      use short_add_long_lt_PRIME,
      split, rw [h1, coe_n_arc_short_eq],
      split,
      { rw [nat.cast_add, coe_n_arc_short_eq, coe_n_arc_long_eq],
        linear_combination h1 + h2 },
    apply nat.le_add_right },
    use n_arc_long,
    use n_arc_short + n_arc_long,
    use long_lt_PRIME,
    use short_add_long_lt_PRIME,
    split, rw [h1, coe_n_arc_long_eq],
    split,
    { rw [nat.cast_add, coe_n_arc_short_eq, coe_n_arc_long_eq],
      linear_combination h1 + h2 },
    apply nat.le_add_left }
end

/-
-- Function: assert_lt_felt
-/

/- assert_lt_felt autogenerated specification -/

def auto_spec_assert_lt_felt_block3 (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ∃ (κ₁ : ℕ) (range_check_ptr₁ : F), spec_assert_le_felt mem κ₁ range_check_ptr a b range_check_ptr₁ ∧
  κ₁ + 5 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₁

/- assert_lt_felt autogenerated specification -/

-- Do not change this definition.
def auto_spec_assert_lt_felt (mem : F → F) (κ : ℕ) (range_check_ptr a b ρ_range_check_ptr : F) : Prop :=
  ((a = b ∧
    a = a + 1 ∧
    ∃ (κ₁ : ℕ), auto_spec_assert_lt_felt_block3 mem κ₁ range_check_ptr a b ρ_range_check_ptr ∧
    κ₁ + 3 ≤ κ) ∨
   (a ≠ b ∧
    ∃ (κ₁ : ℕ), auto_spec_assert_lt_felt_block3 mem κ₁ range_check_ptr a b ρ_range_check_ptr ∧
    κ₁ + 2 ≤ κ))

/- assert_lt_felt soundness theorem -/

theorem sound_assert_lt_felt
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr a b ρ_range_check_ptr : F)
    (h_auto : auto_spec_assert_lt_felt mem κ range_check_ptr a b ρ_range_check_ptr) :
  spec_assert_lt_felt mem κ range_check_ptr a b ρ_range_check_ptr :=
begin
  cases h_auto with h_e h_ne,
  rcases h_e with ⟨_, h_a, _⟩,
  { exfalso, apply @zero_ne_one F, rw [←sub_eq_of_eq_add' h_a, sub_self] },
  rcases h_ne with ⟨h_a_ne_b, _, ⟨_, _, ⟨m, n, m_lt, n_lt, h_am, h_bn, h_le⟩, _, _⟩, _⟩,
  use [m,n, m_lt, n_lt, h_am, h_bn], apply lt_of_le_of_ne h_le,
  by_contra, rw [h, ←h_bn] at h_am, exact absurd h_am h_a_ne_b,
end

/-
-- Function: abs_value
-/

/- abs_value autogenerated specification -/

def auto_spec_abs_value (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ : F) : Prop :=
  ∃ is_positive : F,
  ((is_positive = 0 ∧
    ∃ new_range_check_ptr : F, new_range_check_ptr = range_check_ptr + 1 ∧
    ∃ abs_value : F, abs_value = value * ((-1)) ∧
    mem range_check_ptr = abs_value ∧
    is_range_checked (rc_bound F) (abs_value) ∧
    ∃ range_check_ptr₁ : F, range_check_ptr₁ = new_range_check_ptr ∧
    6 ≤ κ ∧
    ρ_range_check_ptr = range_check_ptr₁ ∧
    ρ = abs_value) ∨
   (is_positive ≠ 0 ∧
    mem range_check_ptr = value ∧
    is_range_checked (rc_bound F) (value) ∧
    ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 1 ∧
    6 ≤ κ ∧
    ρ_range_check_ptr = range_check_ptr₁ ∧
    ρ = value))

/- abs_value soundness theorem -/

theorem sound_abs_value
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value ρ_range_check_ptr ρ : F)
    (h_auto : auto_spec_abs_value mem κ range_check_ptr value ρ_range_check_ptr ρ) :
  spec_abs_value mem κ range_check_ptr value ρ_range_check_ptr ρ :=
begin
  rcases h_auto with ⟨_, ⟨_, _, _, av, aveq, _, rcav, _, _, _, _, ret1eq⟩ | ⟨_, _, rcval, _, _, _, _, ret1eq⟩⟩,
  { rcases rcav with ⟨n, nlt, neq⟩,
    use [n, nlt, ret1eq.trans neq], right,
    rw [ret1eq, aveq, mul_neg_one] },
  rcases rcval with ⟨n, nlt, neq⟩,
  use [n, nlt, ret1eq.trans neq, or.inl ret1eq]
end

/-
-- Function: sign
-/

/- sign autogenerated specification -/

def auto_spec_sign (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ : F) : Prop :=
  ((value = 0 ∧
    5 ≤ κ ∧
    ρ_range_check_ptr = range_check_ptr ∧
    ρ = 0) ∨
   (value ≠ 0 ∧
    ∃ is_positive : F,
    ((is_positive = 0 ∧
      mem range_check_ptr = value * ((-1)) ∧
      is_range_checked (rc_bound F) (value * ((-1))) ∧
      ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 1 ∧
      8 ≤ κ ∧
      ρ_range_check_ptr = range_check_ptr₁ ∧
      ρ = (-1)) ∨
     (is_positive ≠ 0 ∧
      mem range_check_ptr = value ∧
      is_range_checked (rc_bound F) (value) ∧
      ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 1 ∧
      8 ≤ κ ∧
      ρ_range_check_ptr = range_check_ptr₁ ∧
      ρ = 1))))

/- sign soundness theorem -/

theorem sound_sign
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value ρ_range_check_ptr ρ : F)
    (h_auto : auto_spec_sign mem κ range_check_ptr value ρ_range_check_ptr ρ) :
  spec_sign mem κ range_check_ptr value ρ_range_check_ptr ρ :=
begin
  rcases h_auto with (⟨valeq, _, _, ret1eq⟩ |
    ⟨valne, _, ⟨_, _, rc_valneg, _, _, _, _, ret1eq⟩ |  ⟨_, _, rc_val, _, _, _, _, ret1eq⟩⟩),
  { left, use [valeq, ret1eq] },
  { rcases rc_valneg with ⟨n, nlt, neq⟩, rw mul_neg_one at neq,
    right, use [valne, n, nlt, eq_neg_of_eq_neg neq.symm, ret1eq] },
  rcases rc_val with ⟨n, nlt, neq⟩,
  right, use [valne, n, nlt], right, use [neq, ret1eq]
end

/-
-- Function: unsigned_div_rem
-/

/- unsigned_div_rem autogenerated specification -/

def auto_spec_unsigned_div_rem (mem : F → F) (κ : ℕ) (range_check_ptr value div ρ_range_check_ptr ρ_q ρ_r : F) : Prop :=
  ∃ r : F, r = mem range_check_ptr ∧
  is_range_checked (rc_bound F) r ∧
  ∃ q : F, q = mem (range_check_ptr + 1) ∧
  is_range_checked (rc_bound F) q ∧
  ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 2 ∧
  ∃ (κ₁ : ℕ) (range_check_ptr₂ : F), spec_assert_le mem κ₁ range_check_ptr₁ r (div - 1) range_check_ptr₂ ∧
  value = q * div + r ∧
  κ₁ + 12 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₂ ∧
  ρ_q = q ∧
  ρ_r = r

/- unsigned_div_rem soundness theorem -/

theorem sound_unsigned_div_rem
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value div ρ_range_check_ptr ρ_q ρ_r : F)
    (h_auto : auto_spec_unsigned_div_rem mem κ range_check_ptr value div ρ_range_check_ptr ρ_q ρ_r) :
  spec_unsigned_div_rem mem κ range_check_ptr value div ρ_range_check_ptr ρ_q ρ_r :=
begin
  rcases h_auto with ⟨fr, _, ⟨r, rlt, req⟩, fq, _, ⟨q, qlt, qeq⟩, _, _, _, _, ⟨n, nlt, neq⟩, valeq, _, _,
    ret1eq, ret2eq⟩,
  use [q, r, n, qlt, rlt, nlt], split, { rw [valeq, qeq, req] },
  split, { rw [eq_add_of_sub_eq neq, req, nat.cast_add, nat.cast_one, add_assoc] },
  use [ret1eq.trans qeq, ret2eq.trans req]
end

/-
-- Function: signed_div_rem
-/

/- signed_div_rem autogenerated specification -/

def auto_spec_signed_div_rem (mem : F → F) (κ : ℕ) (range_check_ptr value div bound ρ_range_check_ptr ρ_q ρ_r : F) : Prop :=
  ∃ r : F, r = mem range_check_ptr ∧
  is_range_checked (rc_bound F) r ∧
  ∃ biased_q : F, biased_q = mem (range_check_ptr + 1) ∧
  is_range_checked (rc_bound F) biased_q ∧
  ∃ range_check_ptr₁ : F, range_check_ptr₁ = range_check_ptr + 2 ∧
  ∃ q : F, q = biased_q - bound ∧
  value = q * div + r ∧
  ∃ (κ₁ : ℕ) (range_check_ptr₂ : F), spec_assert_le mem κ₁ range_check_ptr₁ r (div - 1) range_check_ptr₂ ∧
  ∃ (κ₂ : ℕ) (range_check_ptr₃ : F), spec_assert_le mem κ₂ range_check_ptr₂ biased_q (2 * bound - 1) range_check_ptr₃ ∧
  κ₁ + κ₂ + 20 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₃ ∧
  ρ_q = q ∧
  ρ_r = r

/- signed_div_rem soundness theorem -/

theorem sound_signed_div_rem
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value div bound ρ_range_check_ptr ρ_q ρ_r : F)
    (h_auto : auto_spec_signed_div_rem mem κ range_check_ptr value div bound ρ_range_check_ptr ρ_q ρ_r) :
  spec_signed_div_rem mem κ range_check_ptr value div bound ρ_range_check_ptr ρ_q ρ_r :=
begin
  rcases h_auto with ⟨fr, _, ⟨r, rlt, req⟩, fbq, _, ⟨bq, bqlt, bqeq⟩, _, _,
                        q, qeq, valeq, _, _, ⟨n, nlt, neq⟩, _, _, ⟨m, mlt, meq⟩, _, _, ret1eq, ret2eq⟩,
  use [bq, r, n, m, q, bqlt, rlt, nlt, mlt],
  split, { rw [qeq, bqeq] },
  split, { rw [valeq, req] },
  split, { rw [eq_add_of_sub_eq neq, req, nat.cast_add, nat.cast_one, add_assoc] },
  split, { rw [eq_add_of_sub_eq meq, bqeq, nat.cast_add, nat.cast_one, add_assoc] },
  use [ret1eq, ret2eq.trans req]
end

/-
-- Function: split_int
-/

/- split_int autogenerated specification -/

def auto_spec_split_int (mem : F → F) (κ : ℕ) (range_check_ptr value n base bound output ρ_range_check_ptr : F) : Prop :=
  ((n = 0 ∧
    value = 0 ∧
    4 ≤ κ ∧
    ρ_range_check_ptr = range_check_ptr) ∨
   (n ≠ 0 ∧
    ∃ low_part : F, low_part = mem output ∧
    ∃ (κ₁ : ℕ) (range_check_ptr₁ : F), spec_assert_nn_le mem κ₁ range_check_ptr low_part (bound - 1) range_check_ptr₁ ∧
    ∃ δ6_0 : F,
    ∃ (κ₂ : ℕ), spec_split_int mem κ₂ range_check_ptr₁ (ddiv (value - low_part) base δ6_0) (n - 1) base bound (output + 1) ρ_range_check_ptr ∧
    κ₁ + κ₂ + 15 ≤ κ))

/- split_int soundness theorem -/

theorem sound_split_int
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value n base bound output ρ_range_check_ptr : F)
    (h_auto : auto_spec_split_int mem κ range_check_ptr value n base bound output ρ_range_check_ptr) :
  spec_split_int mem κ range_check_ptr value n base bound output ρ_range_check_ptr :=
begin
  intro base_nzero,
  cases h_auto,
  -- 0 == n
  rcases h_auto with ⟨neq0, h_veq0, _⟩,
  use [0], split, exact PRIME.char_pos,
  split, { rw neq0, exact nat.cast_zero.symm },
  split, { rw h_veq0, exact (finset.sum_range_zero _).symm },
  { intro h, exfalso, exact nat.not_lt_zero _ h },
  -- 0 < n
  rcases h_auto with ⟨nzero, low_part, low_part_eq, _, _, h_nn_le, ⟨d6, _, i_h, _⟩⟩,
  rcases h_nn_le with ⟨am, an, h_am_bound, h_an_bound, h_a_eq, h_b_eq⟩,
  rcases i_h base_nzero with ⟨i_nn, i_nn_lt, i_nn_eq, i_sum, i_bound⟩,
  have : i_nn + 1 = ring_char F ∨ i_nn + 1 < ring_char F :=
    or.comm.mp (lt_or_eq_of_le (nat.succ_le_of_lt i_nn_lt)),
  cases this with h_eq_ring_char h_lt_ring_char,
  { exfalso, apply nzero,
    rw [eq_add_of_sub_eq i_nn_eq, ←nat.cast_one, ←nat.cast_add, h_eq_ring_char, (ring_char.spec F _)] },
  use [i_nn + 1, h_lt_ring_char],
  split, { rw [eq_add_of_sub_eq i_nn_eq, ←nat.cast_one, ←nat.cast_add] },
  split, {
    rw [add_comm i_nn 1, finset.sum_range_add _ _ _],
    simp [pow_add base 1 _, mul_comm base _],
    simp [←add_assoc, ←mul_assoc],
    rw [ddiv_eq base_nzero, div_eq_iff base_nzero, finset.sum_mul] at i_sum,
    rw [←i_sum], rw [low_part_eq], exact (add_sub_cancel'_right _ _).symm,
  },
  intro h_zero_lt_n,
  use [am + an + 1],
  have h_am_an_lt : am + an + 1 < 2 * rc_bound F,
  { apply lt_of_lt_of_le (nat.add_succ_lt_add h_am_bound h_an_bound), apply le_of_eq, ring },
  use [h_am_an_lt],
  split, { rw [nat.cast_add, nat.cast_one], apply eq_add_of_sub_eq h_b_eq },
  rintro i ilt,
  cases nat.eq_zero_or_pos i with izero zero_lt_i,
  { rw [izero, nat.cast_zero, add_zero, ←low_part_eq],
    use [am, h_a_eq], split, linarith, exact le_of_lt h_am_bound },
  {
    rcases (i_bound (lt_of_lt_of_le zero_lt_i (nat.le_of_lt_succ ilt))) with ⟨i_bn, h_bn_lt, h_bn_eq, h_b⟩,
    have hi : i - 1 < i_nn,
      { rw [nat.sub_one, ←(nat.pred_succ i_nn)],
        exact nat.pred_lt_pred (ne_of_lt zero_lt_i).symm ilt, },
    rcases h_b (i - 1) hi with ⟨m, h_m⟩,
    use m, split,
    { rw [←(h_m.1), nat.cast_sub zero_lt_i, nat.cast_one, add_add_sub_cancel output i 1] },
    have h_2_rc_lt_p : 2 * rc_bound F < PRIME,
    { calc
        2 * rc_bound F ≤ 2 * 2 ^ 128 : by { apply nat.mul_le_mul_of_nonneg_left, exact (rc_bound_hyp F), }
        ... < PRIME : by { rw [PRIME], norm_num1 } },
    have h_m_eq : am + an + 1 = i_bn, {
      have h_b_cast_eq : (↑(am + an + 1) : F) = (↑(i_bn) : F),
      { rw [←h_bn_eq, eq_add_of_sub_eq h_b_eq], norm_cast, },
      apply PRIME.nat_coe_field_inj _ _ h_b_cast_eq,
      exact (lt_trans h_am_an_lt h_2_rc_lt_p), exact (lt_trans h_bn_lt h_2_rc_lt_p),
    },
    rw [h_m_eq], exact h_m.2,
  },

end

/-
-- Function: sqrt
-/

/- sqrt autogenerated specification -/

def auto_spec_sqrt (mem : F → F) (κ : ℕ) (range_check_ptr value ρ_range_check_ptr ρ : F) : Prop :=
  ∃ root : F,
  ∃ (κ₁ : ℕ) (range_check_ptr₁ : F), spec_assert_nn_le mem κ₁ range_check_ptr root (2 ^ 125 - 1) range_check_ptr₁ ∧
  ∃ root_plus_one : F, root_plus_one = root + 1 ∧
  ∃ (κ₂ : ℕ) (range_check_ptr₂ : F), spec_assert_in_range mem κ₂ range_check_ptr₁ value (root * root) (root_plus_one * root_plus_one) range_check_ptr₂ ∧
  κ₁ + κ₂ + 13 ≤ κ ∧
  ρ_range_check_ptr = range_check_ptr₂ ∧
  ρ = root

/- sqrt soundness theorem -/

theorem sound_sqrt
    {mem : F → F}
    (κ : ℕ)
    (range_check_ptr value ρ_range_check_ptr ρ : F)
    (h_auto : auto_spec_sqrt mem κ range_check_ptr value ρ_range_check_ptr ρ) :
  spec_sqrt mem κ range_check_ptr value ρ_range_check_ptr ρ :=
begin
  rcases h_auto with  ⟨root, _, _, h_nn_le_r, rp1, h_rp1, _, _, h_in_range, _, _, ret1eq⟩,
  rcases h_in_range with ⟨n₁, n₂, h_n₁, h_n₂, hrsqr, hr1sqr⟩,
  rcases h_nn_le_r with ⟨r, m, h_r, h_m, h_reqroot, h_rb⟩,

  rw [h_rp1, hrsqr, h_reqroot] at hr1sqr, norm_cast at hr1sqr,
  use [r, h_r, (r ^ 2 + n₁)],
  have h_r_lt_p : r + 1 < PRIME / 2,
  { apply lt_of_le_of_lt (nat.succ_le_of_lt h_r), rw [PRIME], apply lt_of_le_of_lt (rc_bound_hyp F), norm_num1 },
  have h_m_lt_p : m < PRIME / 2,
  { apply lt_trans h_m, rw [PRIME], apply lt_of_le_of_lt (rc_bound_hyp F), norm_num1 },
  have h_r_m_lt_p : r + 1 + m < PRIME, { apply lt_trans (nat.add_lt_add h_r_lt_p h_m_lt_p), rw [PRIME], norm_num1 },
  have h_r1_m_F : (↑(2 ^ 125) : F) = (↑(r + 1 + m) : F),
  { rw [add_assoc, add_comm 1 m, ←add_assoc, nat.cast_add, nat.cast_one],
    apply eq_add_of_sub_eq, rw [←h_rb], norm_cast },
  have h_r1_m : 2 ^ 125 = r + 1 + m,
  { apply PRIME.nat_coe_field_inj (show 2 ^ 125 < PRIME, by { rw [PRIME], norm_num1 }) h_r_m_lt_p h_r1_m_F, },
  have h_r1_le : r + 1 ≤ 2 ^ 125, { rw [h_r1_m], apply nat.le_add_right },
  have h_r1sq : (r + 1) * (r + 1) ≤ 2 ^ 250,
  { rw [(show 2 ^ 250 = (2 ^ 125) ^ 2, { ring })], simp only [pow_two], apply mul_le_mul,
    exact h_r1_le, exact h_r1_le, exact nat.zero_le _, exact nat.zero_le _ },
  have h_r2_nn_lt_p : r * r + n₁ + (n₂ + 1) < PRIME, {
    calc
      r * r + n₁ + (n₂ + 1) ≤ 2 ^ 125 * 2 ^ 125 + 2 ^ 128 + 2 ^ 128 :
      by {  apply nat.add_le_add, apply nat.add_le_add, apply nat.mul_le_mul,
            repeat { exact le_trans (nat.le_succ r) h_r1_le}, exact le_of_lt (lt_of_lt_rc_bound h_n₁),
            apply nat.succ_le_of_lt, exact lt_of_lt_rc_bound h_n₂ }
      ... < PRIME : by { rw [PRIME], norm_num1 },
  },
  have h_r_eq : (r + 1) * (r + 1) = r * r + n₁ + (n₂ + 1),
  { apply PRIME.nat_coe_field_inj _ h_r2_nn_lt_p hr1sqr, apply lt_of_le_of_lt h_r1sq, rw [PRIME], norm_num1 },

  split,
  { have : r * r + n₁ < r * r + n₁ + (n₂ + 1), { apply nat.lt_add_of_zero_lt_left, apply nat.zero_lt_succ, },
    rw [pow_two], apply lt_of_lt_of_le this, rw [←h_r_eq], exact h_r1sq, },
  split, { rw [ret1eq, h_reqroot], },
  split, { rw [hrsqr, h_reqroot, pow_two], norm_cast, },
  rw [nat.eq_sqrt],
  split, { rw [pow_two], apply nat.le_add_right },
  rw [h_r_eq, pow_two], linarith,
end

/-
-- Function: horner_eval
-/

/- horner_eval autogenerated specification -/

def auto_spec_horner_eval (mem : F → F) (κ : ℕ) (n_coefficients coefficients point ρ_res : F) : Prop :=
  ((n_coefficients = 0 ∧
    3 ≤ κ ∧
    ρ_res = 0) ∨
   (n_coefficients ≠ 0 ∧
    ∃ (κ₁ : ℕ) (n_minus_one_res : F), spec_horner_eval mem κ₁ (n_coefficients - 1) (coefficients + 1) point n_minus_one_res ∧
    κ₁ + 9 ≤ κ ∧
    ρ_res = n_minus_one_res * point + mem (coefficients + 0)))

/- horner_eval soundness theorem -/

theorem sound_horner_eval
    {mem : F → F}
    (κ : ℕ)
    (n_coefficients coefficients point ρ_res : F)
    (h_auto : auto_spec_horner_eval mem κ n_coefficients coefficients point ρ_res) :
  spec_horner_eval mem κ n_coefficients coefficients point ρ_res :=
begin
  cases h_auto,
  -- zero case
  rcases h_auto with ⟨neq0, _, h_veq0⟩,
  use [0], split, exact PRIME.char_pos, split,
  rw neq0, exact nat.cast_zero.symm,
  rw h_veq0, exact (finset.sum_range_zero _).symm,
  -- non-zero case
  rcases h_auto with ⟨nzero, _, n_min_1_res, i_h, _, h_ret0⟩,
  rcases i_h with ⟨i_n, i_n_lt, i_n_eq, i_sum⟩,
  have : i_n + 1 = ring_char F ∨ i_n + 1 < ring_char F :=
    or.comm.mp (lt_or_eq_of_le (nat.succ_le_of_lt i_n_lt)),
  cases this with h_eq_ring_char h_lt_ring_char,
  { exfalso, apply nzero,
    rw [eq_add_of_sub_eq i_n_eq, ←nat.cast_one, ←nat.cast_add, h_eq_ring_char, (ring_char.spec F _)] },
  use [i_n + 1, h_lt_ring_char], split,
  { rw [eq_add_of_sub_eq i_n_eq, ←nat.cast_one, ←nat.cast_add] },
  {
    rw [add_comm i_n 1, finset.sum_range_add _ _ _],
    simp [pow_add point 1 _, mul_comm point _],
    simp [←add_assoc, ←mul_assoc],
    rw [h_ret0, add_comm, add_zero, add_left_cancel_iff, i_sum, finset.sum_mul]
  },
end


/-
-- Function: is_quad_residue
-/

/- is_quad_residue autogenerated specification -/

-- Do not change this definition.
def auto_spec_is_quad_residue (mem : F → F) (κ : ℕ) (x ρ : F) : Prop :=
  ∃ y : F,
  ∃ y_squared : F, y_squared = y * y ∧
  ((y_squared = x ∧
    7 ≤ κ ∧
    ρ = TRUE) ∨
   (y_squared ≠ x ∧
    3 * y_squared = x ∧
    8 ≤ κ ∧
    ρ = FALSE))

-- You may change anything in this definition except the name and arguments.
def spec_is_quad_residue (mem : F → F) (κ : ℕ) (x ρ : F) : Prop :=
  auto_spec_is_quad_residue mem κ x ρ

/- is_quad_residue soundness theorem -/

-- Do not change the statement of this theorem. You may change the proof.
theorem sound_is_quad_residue
    {mem : F → F}
    (κ : ℕ)
    (x ρ : F)
    (h_auto : auto_spec_is_quad_residue mem κ x ρ) :
  spec_is_quad_residue mem κ x ρ :=
begin
  exact h_auto
end

end starkware.cairo.common.math
