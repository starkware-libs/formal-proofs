/-
File: signature_recover_public_key_fast_ec_add_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .signature_recover_public_key_code
import ..signature_recover_public_key_spec
import .signature_recover_public_key_unreduced_sqr_soundness
import .signature_recover_public_key_compute_slope_soundness
open tactic

open starkware.cairo.common.cairo_secp.ec
open starkware.cairo.common.cairo_secp.bigint
open starkware.cairo.common.cairo_secp.field

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.cairo_secp.ec.fast_ec_add autogenerated soundness theorem -/

theorem auto_sound_fast_ec_add_block9
    -- An independent ap variable.
    (ap : F)
    -- arguments
    (range_check_ptr : F) (point0 point1 : EcPoint F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_fast_ec_add σ.pc)
    -- all dependencies are in memory
    (h_mem_4 : mem_at mem code_nondet_bigint3 (σ.pc  - 317))
    (h_mem_5 : mem_at mem code_unreduced_mul (σ.pc  - 305))
    (h_mem_6 : mem_at mem code_unreduced_sqr (σ.pc  - 285))
    (h_mem_7 : mem_at mem code_verify_zero (σ.pc  - 269))
    (h_mem_13 : mem_at mem code_compute_slope (σ.pc  - 97))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 15))
    (hin_point0 : point0 = cast_EcPoint mem (σ.fp - 14))
    (hin_point1 : point1 = cast_EcPoint mem (σ.fp - 8))
    (νbound : ℕ)
    -- conclusion
  : ensuresb_ret νbound mem
    {pc := σ.pc + 28, ap := ap, fp := σ.fp}
    (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 15)) (mem $ τ.ap - 7)
        (auto_spec_fast_ec_add_block9 mem κ range_check_ptr point0 point1 (mem (τ.ap - 7)) (cast_EcPoint mem (τ.ap - 6)))) :=
begin
  have h_mem_rec := h_mem,
  unpack_memory code_fast_ec_add at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45, hpc46, hpc47, hpc48, hpc49, hpc50, hpc51, hpc52, hpc53, hpc54, hpc55, hpc56, hpc57, hpc58, hpc59, hpc60, hpc61, hpc62, hpc63, hpc64, hpc65, hpc66, hpc67, hpc68, hpc69, hpc70, hpc71, hpc72, hpc73, hpc74, hpc75, hpc76, hpc77, hpc78, hpc79, hpc80, hpc81, hpc82, hpc83, hpc84, hpc85, hpc86⟩,
  -- function call
  step_assert_eq hpc28 with arg0,
  step_assert_eq hpc29 with arg1,
  step_assert_eq hpc30 with arg2,
  step_assert_eq hpc31 with arg3,
  step_assert_eq hpc32 with arg4,
  step_assert_eq hpc33 with arg5,
  step_assert_eq hpc34 with arg6,
  step_assert_eq hpc35 with arg7,
  step_assert_eq hpc36 with arg8,
  step_assert_eq hpc37 with arg9,
  step_assert_eq hpc38 with arg10,
  step_assert_eq hpc39 with arg11,
  step_assert_eq hpc40 with arg12,
  step_sub hpc41 (auto_sound_compute_slope mem _ range_check_ptr point0 point1 _ _ _ _ _ _ _),
  { rw hpc42, norm_num2, exact h_mem_13 },
  { rw hpc42, norm_num2, exact h_mem_4 },
  { rw hpc42, norm_num2, exact h_mem_5 },
  { rw hpc42, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
    try { dsimp [cast_EcPoint, cast_BigInt3] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call43 ap43 h_call43,
  rcases h_call43 with ⟨h_call43_ap_offset, h_call43⟩,
  rcases h_call43 with ⟨rc_m43, rc_mle43, hl_range_check_ptr₁, h_call43⟩,
  generalize' hr_rev_range_check_ptr₁: mem (ap43 - 4) = range_check_ptr₁,
  have htv_range_check_ptr₁ := hr_rev_range_check_ptr₁.symm, clear hr_rev_range_check_ptr₁,
  generalize' hr_rev_slope: cast_BigInt3 mem (ap43 - 3) = slope,
  simp only [hr_rev_slope] at h_call43,
  have htv_slope := hr_rev_slope.symm, clear hr_rev_slope,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10 ,arg11 ,arg12] at hl_range_check_ptr₁ },
  rw [←htv_range_check_ptr₁, ←hin_range_check_ptr] at hl_range_check_ptr₁,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9 ,arg10 ,arg11 ,arg12] at h_call43 },
  rw [hin_range_check_ptr] at h_call43,
  clear arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9 arg10 arg11 arg12,
  -- function call
  step_sub hpc43 (auto_sound_unreduced_sqr mem _ slope _ _),
  { rw hpc44, norm_num2, exact h_mem_6 },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { simp only [h_call43_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call45 ap45 h_call45,
  rcases h_call45 with ⟨h_call45_ap_offset, h_call45⟩,
  generalize' hr_rev_slope_sqr: cast_UnreducedBigInt3 mem (ap45 - 3) = slope_sqr,
  simp only [hr_rev_slope_sqr] at h_call45,
  have htv_slope_sqr := hr_rev_slope_sqr.symm, clear hr_rev_slope_sqr,
  clear ,
  -- function call
  step_assert_eq hpc45 with arg0,
  step_sub hpc46 (auto_sound_nondet_bigint3 mem _ range_check_ptr₁ _ _),
  { rw hpc47, norm_num2, exact h_mem_4 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr] },
    try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0] },
    try { simp only [h_call43_ap_offset, h_call45_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call48 ap48 h_call48,
  rcases h_call48 with ⟨h_call48_ap_offset, h_call48⟩,
  rcases h_call48 with ⟨rc_m48, rc_mle48, hl_range_check_ptr₂, h_call48⟩,
  generalize' hr_rev_range_check_ptr₂: mem (ap48 - 4) = range_check_ptr₂,
  have htv_range_check_ptr₂ := hr_rev_range_check_ptr₂.symm, clear hr_rev_range_check_ptr₂,
  generalize' hr_rev_new_x: cast_BigInt3 mem (ap48 - 3) = new_x,
  simp only [hr_rev_new_x] at h_call48,
  have htv_new_x := hr_rev_new_x.symm, clear hr_rev_new_x,
  try { simp only [arg0] at hl_range_check_ptr₂ },
  try { rw [h_call45_ap_offset] at hl_range_check_ptr₂ }, try { arith_simps at hl_range_check_ptr₂ },
  rw [←htv_range_check_ptr₂, ←htv_range_check_ptr₁] at hl_range_check_ptr₂,
  try { simp only [arg0] at h_call48 },
  try { rw [h_call45_ap_offset] at h_call48 }, try { arith_simps at h_call48 },
  rw [←htv_range_check_ptr₁, hl_range_check_ptr₁, hin_range_check_ptr] at h_call48,
  clear arg0,
  -- function call
  step_assert_eq hpc48 with arg0,
  step_sub hpc49 (auto_sound_nondet_bigint3 mem _ range_check_ptr₂ _ _),
  { rw hpc50, norm_num2, exact h_mem_4 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x] },
    try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [arg0] },
    try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call51 ap51 h_call51,
  rcases h_call51 with ⟨h_call51_ap_offset, h_call51⟩,
  rcases h_call51 with ⟨rc_m51, rc_mle51, hl_range_check_ptr₃, h_call51⟩,
  generalize' hr_rev_range_check_ptr₃: mem (ap51 - 4) = range_check_ptr₃,
  have htv_range_check_ptr₃ := hr_rev_range_check_ptr₃.symm, clear hr_rev_range_check_ptr₃,
  generalize' hr_rev_new_y: cast_BigInt3 mem (ap51 - 3) = new_y,
  simp only [hr_rev_new_y] at h_call51,
  have htv_new_y := hr_rev_new_y.symm, clear hr_rev_new_y,
  try { simp only [arg0] at hl_range_check_ptr₃ },
  rw [←htv_range_check_ptr₃, ←htv_range_check_ptr₂] at hl_range_check_ptr₃,
  try { simp only [arg0] at h_call51 },
  rw [←htv_range_check_ptr₂, hl_range_check_ptr₂, hl_range_check_ptr₁, hin_range_check_ptr] at h_call51,
  clear arg0,
  -- function call
  step_assert_eq hpc51 with arg0,
  step_assert_eq hpc52 with arg1,
  step_assert_eq hpc53 with arg2,
  step_assert_eq hpc54 with arg3,
  step_assert_eq hpc55 with arg4,
  step_assert_eq hpc56 with arg5,
  step_assert_eq hpc57 with arg6,
  step_assert_eq hpc58 with arg7,
  step_assert_eq hpc59 with arg8,
  step_assert_eq hpc60 with arg9,
  step_sub hpc61 (auto_sound_verify_zero mem _ range_check_ptr₃ {
    d0 := slope_sqr.d0 - new_x.d0 - point0.x.d0 - point1.x.d0,
    d1 := slope_sqr.d1 - new_x.d1 - point0.x.d1 - point1.x.d1,
    d2 := slope_sqr.d2 - new_x.d2 - point0.x.d2 - point1.x.d2
  } _ _ _),
  { rw hpc62, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x, htv_range_check_ptr₃, htv_new_y] },
    try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [(eq_sub_of_eq_add arg0), (eq_sub_of_eq_add arg1), (eq_sub_of_eq_add arg2), (eq_sub_of_eq_add arg3), (eq_sub_of_eq_add arg4), (eq_sub_of_eq_add arg5), arg6, (eq_sub_of_eq_add arg7), (eq_sub_of_eq_add arg8), (eq_sub_of_eq_add arg9)] },
    try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset, h_call51_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x, htv_range_check_ptr₃, htv_new_y] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [(eq_sub_of_eq_add arg0), (eq_sub_of_eq_add arg1), (eq_sub_of_eq_add arg2), (eq_sub_of_eq_add arg3), (eq_sub_of_eq_add arg4), (eq_sub_of_eq_add arg5), arg6, (eq_sub_of_eq_add arg7), (eq_sub_of_eq_add arg8), (eq_sub_of_eq_add arg9)] },
      try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset, h_call51_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call63 ap63 h_call63,
  rcases h_call63 with ⟨h_call63_ap_offset, h_call63⟩,
  rcases h_call63 with ⟨rc_m63, rc_mle63, hl_range_check_ptr₄, h_call63⟩,
  generalize' hr_rev_range_check_ptr₄: mem (ap63 - 1) = range_check_ptr₄,
  have htv_range_check_ptr₄ := hr_rev_range_check_ptr₄.symm, clear hr_rev_range_check_ptr₄,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9] at hl_range_check_ptr₄ },
  rw [←htv_range_check_ptr₄, ←htv_range_check_ptr₃] at hl_range_check_ptr₄,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6 ,arg7 ,arg8 ,arg9] at h_call63 },
  rw [←htv_range_check_ptr₃, hl_range_check_ptr₃, hl_range_check_ptr₂, hl_range_check_ptr₁, hin_range_check_ptr] at h_call63,
  clear arg0 arg1 arg2 arg3 arg4 arg5 arg6 arg7 arg8 arg9,
  -- function call
  step_assert_eq hpc63 with arg0,
  step_assert_eq hpc64 with arg1,
  step_assert_eq hpc65 with arg2,
  step_assert_eq hpc66 with arg3,
  step_assert_eq hpc67 with arg4,
  step_assert_eq hpc68 with arg5,
  step_sub hpc69 (auto_sound_unreduced_mul mem _ {
    d0 := point0.x.d0 - new_x.d0,
    d1 := point0.x.d1 - new_x.d1,
    d2 := point0.x.d2 - new_x.d2
  } slope _ _ _),
  { rw hpc70, norm_num2, exact h_mem_5 },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x, htv_range_check_ptr₃, htv_new_y, htv_range_check_ptr₄] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [(eq_sub_of_eq_add arg0), (eq_sub_of_eq_add arg1), (eq_sub_of_eq_add arg2), arg3, arg4, arg5] },
      try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset, h_call51_ap_offset, h_call63_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x, htv_range_check_ptr₃, htv_new_y, htv_range_check_ptr₄] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [(eq_sub_of_eq_add arg0), (eq_sub_of_eq_add arg1), (eq_sub_of_eq_add arg2), arg3, arg4, arg5] },
      try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset, h_call51_ap_offset, h_call63_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call71 ap71 h_call71,
  rcases h_call71 with ⟨h_call71_ap_offset, h_call71⟩,
  generalize' hr_rev_x_diff_slope: cast_UnreducedBigInt3 mem (ap71 - 3) = x_diff_slope,
  simp only [hr_rev_x_diff_slope] at h_call71,
  have htv_x_diff_slope := hr_rev_x_diff_slope.symm, clear hr_rev_x_diff_slope,
  clear arg0 arg1 arg2 arg3 arg4 arg5,
  -- function call
  step_assert_eq hpc71 with arg0,
  step_assert_eq hpc72 with arg1,
  step_assert_eq hpc73 with arg2,
  step_assert_eq hpc74 with arg3,
  step_assert_eq hpc75 with arg4,
  step_assert_eq hpc76 with arg5,
  step_assert_eq hpc77 with arg6,
  step_sub hpc78 (auto_sound_verify_zero mem _ range_check_ptr₄ {
    d0 := x_diff_slope.d0 - point0.y.d0 - new_y.d0,
    d1 := x_diff_slope.d1 - point0.y.d1 - new_y.d1,
    d2 := x_diff_slope.d2 - point0.y.d2 - new_y.d2
  } _ _ _),
  { rw hpc79, norm_num2, exact h_mem_7 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x, htv_range_check_ptr₃, htv_new_y, htv_range_check_ptr₄, htv_x_diff_slope] },
    try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
    try { arith_simps }, try { simp only [(eq_sub_of_eq_add arg0), (eq_sub_of_eq_add arg1), (eq_sub_of_eq_add arg2), arg3, (eq_sub_of_eq_add arg4), (eq_sub_of_eq_add arg5), (eq_sub_of_eq_add arg6)] },
    try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset, h_call51_ap_offset, h_call63_ap_offset, h_call71_ap_offset] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { ext } ; {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x, htv_range_check_ptr₃, htv_new_y, htv_range_check_ptr₄, htv_x_diff_slope] },
      try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
      try { arith_simps }, try { simp only [(eq_sub_of_eq_add arg0), (eq_sub_of_eq_add arg1), (eq_sub_of_eq_add arg2), arg3, (eq_sub_of_eq_add arg4), (eq_sub_of_eq_add arg5), (eq_sub_of_eq_add arg6)] },
      try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset, h_call51_ap_offset, h_call63_ap_offset, h_call71_ap_offset] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },}, },
  intros κ_call80 ap80 h_call80,
  rcases h_call80 with ⟨h_call80_ap_offset, h_call80⟩,
  rcases h_call80 with ⟨rc_m80, rc_mle80, hl_range_check_ptr₅, h_call80⟩,
  generalize' hr_rev_range_check_ptr₅: mem (ap80 - 1) = range_check_ptr₅,
  have htv_range_check_ptr₅ := hr_rev_range_check_ptr₅.symm, clear hr_rev_range_check_ptr₅,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6] at hl_range_check_ptr₅ },
  try { rw [h_call71_ap_offset] at hl_range_check_ptr₅ }, try { arith_simps at hl_range_check_ptr₅ },
  rw [←htv_range_check_ptr₅, ←htv_range_check_ptr₄] at hl_range_check_ptr₅,
  try { simp only [arg0 ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6] at h_call80 },
  try { rw [h_call71_ap_offset] at h_call80 }, try { arith_simps at h_call80 },
  rw [←htv_range_check_ptr₄, hl_range_check_ptr₄, hl_range_check_ptr₃, hl_range_check_ptr₂, hl_range_check_ptr₁, hin_range_check_ptr] at h_call80,
  clear arg0 arg1 arg2 arg3 arg4 arg5 arg6,
  -- return
  step_assert_eq hpc80 with hret0,
  step_assert_eq hpc81 with hret1,
  step_assert_eq hpc82 with hret2,
  step_assert_eq hpc83 with hret3,
  step_assert_eq hpc84 with hret4,
  step_assert_eq hpc85 with hret5,
  step_ret hpc86,
  -- finish
  step_done, use_only [rfl, rfl],
  -- range check condition
  use_only (rc_m43+rc_m48+rc_m51+rc_m63+rc_m80+0+0), split,
  linarith [rc_mle43, rc_mle48, rc_mle51, rc_mle63, rc_mle80],
  split,
  { arith_simps, try { simp only [hret0 ,hret1 ,hret2 ,hret3 ,hret4 ,hret5] },
    rw [←htv_range_check_ptr₅, hl_range_check_ptr₅, hl_range_check_ptr₄, hl_range_check_ptr₃, hl_range_check_ptr₂, hl_range_check_ptr₁, hin_range_check_ptr],
    try { arith_simps, refl <|> norm_cast }, try { refl } },
  intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
  have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
  -- Final Proof
  dsimp [auto_spec_fast_ec_add_block9],
  try { norm_num1 }, try { arith_simps },
  use_only [κ_call43],
  use_only [range_check_ptr₁],
  use_only [slope],
  have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
  have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
  have spec43 := h_call43 rc_h_range_check_ptr',
  rw [←hin_range_check_ptr, ←htv_range_check_ptr₁] at spec43,
  try { dsimp at spec43, arith_simps at spec43 },
  use_only [spec43],
  use_only [κ_call45],
  use_only [slope_sqr],
  try { dsimp at h_call45, arith_simps at h_call45 },
  try { use_only [h_call45] },
  use_only [κ_call48],
  use_only [range_check_ptr₂],
  use_only [new_x],
  have rc_h_range_check_ptr₂ := range_checked_offset' rc_h_range_check_ptr₁,
  have rc_h_range_check_ptr₂' := range_checked_add_right rc_h_range_check_ptr₂, try { norm_cast at rc_h_range_check_ptr₂' },
  have spec48 := h_call48 rc_h_range_check_ptr₁',
  rw [←hin_range_check_ptr, ←hl_range_check_ptr₁, ←htv_range_check_ptr₂] at spec48,
  try { dsimp at spec48, arith_simps at spec48 },
  use_only [spec48],
  use_only [κ_call51],
  use_only [range_check_ptr₃],
  use_only [new_y],
  have rc_h_range_check_ptr₃ := range_checked_offset' rc_h_range_check_ptr₂,
  have rc_h_range_check_ptr₃' := range_checked_add_right rc_h_range_check_ptr₃, try { norm_cast at rc_h_range_check_ptr₃' },
  have spec51 := h_call51 rc_h_range_check_ptr₂',
  rw [←hin_range_check_ptr, ←hl_range_check_ptr₁, ←hl_range_check_ptr₂, ←htv_range_check_ptr₃] at spec51,
  try { dsimp at spec51, arith_simps at spec51 },
  use_only [spec51],
  use_only [κ_call63],
  use_only [range_check_ptr₄],
  have rc_h_range_check_ptr₄ := range_checked_offset' rc_h_range_check_ptr₃,
  have rc_h_range_check_ptr₄' := range_checked_add_right rc_h_range_check_ptr₄, try { norm_cast at rc_h_range_check_ptr₄' },
  have spec63 := h_call63 rc_h_range_check_ptr₃',
  rw [←hin_range_check_ptr, ←hl_range_check_ptr₁, ←hl_range_check_ptr₂, ←hl_range_check_ptr₃, ←htv_range_check_ptr₄] at spec63,
  try { dsimp at spec63, arith_simps at spec63 },
  use_only [spec63],
  use_only [κ_call71],
  use_only [x_diff_slope],
  try { dsimp at h_call71, arith_simps at h_call71 },
  try { use_only [h_call71] },
  use_only [κ_call80],
  use_only [range_check_ptr₅],
  have rc_h_range_check_ptr₅ := range_checked_offset' rc_h_range_check_ptr₄,
  have rc_h_range_check_ptr₅' := range_checked_add_right rc_h_range_check_ptr₅, try { norm_cast at rc_h_range_check_ptr₅' },
  have spec80 := h_call80 rc_h_range_check_ptr₄',
  rw [←hin_range_check_ptr, ←hl_range_check_ptr₁, ←hl_range_check_ptr₂, ←hl_range_check_ptr₃, ←hl_range_check_ptr₄, ←htv_range_check_ptr₅] at spec80,
  try { dsimp at spec80, arith_simps at spec80 },
  use_only [spec80],
  try { split, linarith },
  try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1, htv_range_check_ptr₁, htv_slope, htv_slope_sqr, htv_range_check_ptr₂, htv_new_x, htv_range_check_ptr₃, htv_new_y, htv_range_check_ptr₄, htv_x_diff_slope, htv_range_check_ptr₅] }, },
  try { dsimp [cast_EcPoint, cast_BigInt3, cast_UnreducedBigInt3] },
  try { arith_simps }, try { simp only [hret0, hret1, hret2, hret3, hret4, hret5] },
  try { simp only [h_call43_ap_offset, h_call45_ap_offset, h_call48_ap_offset, h_call51_ap_offset, h_call63_ap_offset, h_call71_ap_offset, h_call80_ap_offset] },
  try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
end

theorem auto_sound_fast_ec_add_block5
    -- An independent ap variable.
    (ap : F)
    -- arguments
    (range_check_ptr : F) (point0 point1 : EcPoint F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_fast_ec_add σ.pc)
    -- all dependencies are in memory
    (h_mem_4 : mem_at mem code_nondet_bigint3 (σ.pc  - 317))
    (h_mem_5 : mem_at mem code_unreduced_mul (σ.pc  - 305))
    (h_mem_6 : mem_at mem code_unreduced_sqr (σ.pc  - 285))
    (h_mem_7 : mem_at mem code_verify_zero (σ.pc  - 269))
    (h_mem_13 : mem_at mem code_compute_slope (σ.pc  - 97))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 15))
    (hin_point0 : point0 = cast_EcPoint mem (σ.fp - 14))
    (hin_point1 : point1 = cast_EcPoint mem (σ.fp - 8))
    (νbound : ℕ)
    -- conclusion
  : ensuresb_ret νbound mem
    {pc := σ.pc + 14, ap := ap, fp := σ.fp}
    (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 15)) (mem $ τ.ap - 7)
        (auto_spec_fast_ec_add_block5 mem κ range_check_ptr point0 point1 (mem (τ.ap - 7)) (cast_EcPoint mem (τ.ap - 6)))) :=
begin
  have h_mem_rec := h_mem,
  unpack_memory code_fast_ec_add at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45, hpc46, hpc47, hpc48, hpc49, hpc50, hpc51, hpc52, hpc53, hpc54, hpc55, hpc56, hpc57, hpc58, hpc59, hpc60, hpc61, hpc62, hpc63, hpc64, hpc65, hpc66, hpc67, hpc68, hpc69, hpc70, hpc71, hpc72, hpc73, hpc74, hpc75, hpc76, hpc77, hpc78, hpc79, hpc80, hpc81, hpc82, hpc83, hpc84, hpc85, hpc86⟩,
  -- if statement
  step_jnz hpc14 hpc15 with hcond hcond,
  {
    -- if: positive branch
    have a14 : point1.x.d0 = 0, {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a14 }, try { arith_simps at a14 },
    clear hcond,
    -- if statement
    step_jnz hpc16 hpc17 with hcond hcond,
    {
      -- if: positive branch
      have a16 : point1.x.d1 = 0, {
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
        try { dsimp [cast_EcPoint, cast_BigInt3] },
        try { arith_simps }, try { simp only [hcond] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a16 }, try { arith_simps at a16 },
      clear hcond,
      -- if statement
      step_jnz hpc18 hpc19 with hcond hcond,
      {
        -- if: positive branch
        have a18 : point1.x.d2 = 0, {
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
          try { dsimp [cast_EcPoint, cast_BigInt3] },
          try { arith_simps }, try { simp only [hcond] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
        },
        try { dsimp at a18 }, try { arith_simps at a18 },
        clear hcond,
        -- return
        step_assert_eq hpc20 with hret0,
        step_assert_eq hpc21 with hret1,
        step_assert_eq hpc22 with hret2,
        step_assert_eq hpc23 with hret3,
        step_assert_eq hpc24 with hret4,
        step_assert_eq hpc25 with hret5,
        step_assert_eq hpc26 with hret6,
        step_ret hpc27,
        -- finish
        step_done, use_only [rfl, rfl],
        -- range check condition
        use_only (0+0), split,
        linarith [],
        split,
        { arith_simps, try { simp only [hret0 ,hret1 ,hret2 ,hret3 ,hret4 ,hret5 ,hret6] },
          try { arith_simps, refl <|> norm_cast }, try { refl } },
        intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
        have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
        -- Final Proof
        dsimp [auto_spec_fast_ec_add_block5],
        try { norm_num1 }, try { arith_simps },
        left,
        use_only [a14],
        left,
        use_only [a16],
        left,
        use_only [a18],
        try { split, linarith },
        try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] }, },
        try { dsimp [cast_EcPoint, cast_BigInt3] },
        try { arith_simps }, try { simp only [hret0, hret1, hret2, hret3, hret4, hret5, hret6] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      {
        -- if: negative branch
        have a18 : point1.x.d2 ≠ 0, {
          try { simp only [ne.def] },
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
          try { dsimp [cast_EcPoint, cast_BigInt3] },
          try { arith_simps }, try { simp only [hcond] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
        },
        try { dsimp at a18 }, try { arith_simps at a18 },
        clear hcond,
        -- Use the block soundness theorem.
        apply ensuresb_ret_trans (auto_sound_fast_ec_add_block9 mem σ _ range_check_ptr point0 point1 h_mem_rec h_mem_4 h_mem_5 h_mem_6 h_mem_7 h_mem_13 hin_range_check_ptr hin_point0 hin_point1 νbound),
        intros κ_block9 τ, try { arith_simps },
        intro h_block9,
        rcases h_block9 with ⟨rc_m_block9, rc_m_le_block9, hblk_range_check_ptr₁, h_block9⟩,
        -- range check condition
        use_only (rc_m_block9+0+0), split,
        linarith [rc_m_le_block9],
        split,
        { arith_simps, try { simp only [hblk_range_check_ptr₁] },
          try { arith_simps, refl <|> norm_cast }, try { refl } },
        intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
        have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
        -- Final Proof
        dsimp [auto_spec_fast_ec_add_block5],
        try { norm_num1 }, try { arith_simps },
        left,
        use_only [a14],
        left,
        use_only [a16],
        right,
        use_only [a18],
        have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
        have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
        have h_block9' := h_block9 rc_h_range_check_ptr',
        try { rw [←hin_range_check_ptr] at h_block9' },
        try { dsimp at h_block9, arith_simps at h_block9' },
        have h_block9 := h_block9',
        use_only[κ_block9],
        use [h_block9],
        try { linarith }
      }
    },
    {
      -- if: negative branch
      have a16 : point1.x.d1 ≠ 0, {
        try { simp only [ne.def] },
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
        try { dsimp [cast_EcPoint, cast_BigInt3] },
        try { arith_simps }, try { simp only [hcond] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a16 }, try { arith_simps at a16 },
      clear hcond,
      -- Use the block soundness theorem.
      apply ensuresb_ret_trans (auto_sound_fast_ec_add_block9 mem σ _ range_check_ptr point0 point1 h_mem_rec h_mem_4 h_mem_5 h_mem_6 h_mem_7 h_mem_13 hin_range_check_ptr hin_point0 hin_point1 νbound),
      intros κ_block9 τ, try { arith_simps },
      intro h_block9,
      rcases h_block9 with ⟨rc_m_block9, rc_m_le_block9, hblk_range_check_ptr₁, h_block9⟩,
      -- range check condition
      use_only (rc_m_block9+0+0), split,
      linarith [rc_m_le_block9],
      split,
      { arith_simps, try { simp only [hblk_range_check_ptr₁] },
        try { arith_simps, refl <|> norm_cast }, try { refl } },
      intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
      have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
      -- Final Proof
      dsimp [auto_spec_fast_ec_add_block5],
      try { norm_num1 }, try { arith_simps },
      left,
      use_only [a14],
      right,
      use_only [a16],
      have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
      have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
      have h_block9' := h_block9 rc_h_range_check_ptr',
      try { rw [←hin_range_check_ptr] at h_block9' },
      try { dsimp at h_block9, arith_simps at h_block9' },
      have h_block9 := h_block9',
      use_only[κ_block9],
      use [h_block9],
      try { linarith }
    }
  },
  {
    -- if: negative branch
    have a14 : point1.x.d0 ≠ 0, {
      try { simp only [ne.def] },
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a14 }, try { arith_simps at a14 },
    clear hcond,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (auto_sound_fast_ec_add_block9 mem σ _ range_check_ptr point0 point1 h_mem_rec h_mem_4 h_mem_5 h_mem_6 h_mem_7 h_mem_13 hin_range_check_ptr hin_point0 hin_point1 νbound),
    intros κ_block9 τ, try { arith_simps },
    intro h_block9,
    rcases h_block9 with ⟨rc_m_block9, rc_m_le_block9, hblk_range_check_ptr₁, h_block9⟩,
    -- range check condition
    use_only (rc_m_block9+0+0), split,
    linarith [rc_m_le_block9],
    split,
    { arith_simps, try { simp only [hblk_range_check_ptr₁] },
      try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
    have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
    -- Final Proof
    dsimp [auto_spec_fast_ec_add_block5],
    try { norm_num1 }, try { arith_simps },
    right,
    use_only [a14],
    have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
    have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
    have h_block9' := h_block9 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at h_block9' },
    try { dsimp at h_block9, arith_simps at h_block9' },
    have h_block9 := h_block9',
    use_only[κ_block9],
    use [h_block9],
    try { linarith }
  }
end

theorem auto_sound_fast_ec_add
    -- arguments
    (range_check_ptr : F) (point0 point1 : EcPoint F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_fast_ec_add σ.pc)
    -- all dependencies are in memory
    (h_mem_4 : mem_at mem code_nondet_bigint3 (σ.pc  - 317))
    (h_mem_5 : mem_at mem code_unreduced_mul (σ.pc  - 305))
    (h_mem_6 : mem_at mem code_unreduced_sqr (σ.pc  - 285))
    (h_mem_7 : mem_at mem code_verify_zero (σ.pc  - 269))
    (h_mem_13 : mem_at mem code_compute_slope (σ.pc  - 97))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 15))
    (hin_point0 : point0 = cast_EcPoint mem (σ.fp - 14))
    (hin_point1 : point1 = cast_EcPoint mem (σ.fp - 8))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 15)) (mem $ τ.ap - 7)
        (spec_fast_ec_add mem κ range_check_ptr point0 point1 (mem (τ.ap - 7)) (cast_EcPoint mem (τ.ap - 6)))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  have h_mem_rec := h_mem,
  unpack_memory code_fast_ec_add at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10, hpc11, hpc12, hpc13, hpc14, hpc15, hpc16, hpc17, hpc18, hpc19, hpc20, hpc21, hpc22, hpc23, hpc24, hpc25, hpc26, hpc27, hpc28, hpc29, hpc30, hpc31, hpc32, hpc33, hpc34, hpc35, hpc36, hpc37, hpc38, hpc39, hpc40, hpc41, hpc42, hpc43, hpc44, hpc45, hpc46, hpc47, hpc48, hpc49, hpc50, hpc51, hpc52, hpc53, hpc54, hpc55, hpc56, hpc57, hpc58, hpc59, hpc60, hpc61, hpc62, hpc63, hpc64, hpc65, hpc66, hpc67, hpc68, hpc69, hpc70, hpc71, hpc72, hpc73, hpc74, hpc75, hpc76, hpc77, hpc78, hpc79, hpc80, hpc81, hpc82, hpc83, hpc84, hpc85, hpc86⟩,
  -- if statement
  step_jnz hpc0 hpc1 with hcond hcond,
  {
    -- if: positive branch
    have a0 : point0.x.d0 = 0, {
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a0 }, try { arith_simps at a0 },
    clear hcond,
    -- if statement
    step_jnz hpc2 hpc3 with hcond hcond,
    {
      -- if: positive branch
      have a2 : point0.x.d1 = 0, {
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
        try { dsimp [cast_EcPoint, cast_BigInt3] },
        try { arith_simps }, try { simp only [hcond] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a2 }, try { arith_simps at a2 },
      clear hcond,
      -- if statement
      step_jnz hpc4 hpc5 with hcond hcond,
      {
        -- if: positive branch
        have a4 : point0.x.d2 = 0, {
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
          try { dsimp [cast_EcPoint, cast_BigInt3] },
          try { arith_simps }, try { simp only [hcond] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
        },
        try { dsimp at a4 }, try { arith_simps at a4 },
        clear hcond,
        -- return
        step_assert_eq hpc6 with hret0,
        step_assert_eq hpc7 with hret1,
        step_assert_eq hpc8 with hret2,
        step_assert_eq hpc9 with hret3,
        step_assert_eq hpc10 with hret4,
        step_assert_eq hpc11 with hret5,
        step_assert_eq hpc12 with hret6,
        step_ret hpc13,
        -- finish
        step_done, use_only [rfl, rfl],
        -- range check condition
        use_only (0+0), split,
        linarith [],
        split,
        { arith_simps, try { simp only [hret0 ,hret1 ,hret2 ,hret3 ,hret4 ,hret5 ,hret6] },
          try { arith_simps, refl <|> norm_cast }, try { refl } },
        intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
        have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
        -- Final Proof
        -- user-provided reduction
        suffices auto_spec: auto_spec_fast_ec_add mem _ range_check_ptr point0 point1 _ _,
        { apply sound_fast_ec_add, apply auto_spec },
        -- prove the auto generated assertion
        dsimp [auto_spec_fast_ec_add],
        try { norm_num1 }, try { arith_simps },
        left,
        use_only [a0],
        left,
        use_only [a2],
        left,
        use_only [a4],
        try { split, linarith },
        try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] }, },
        try { dsimp [cast_EcPoint, cast_BigInt3] },
        try { arith_simps }, try { simp only [hret0, hret1, hret2, hret3, hret4, hret5, hret6] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      {
        -- if: negative branch
        have a4 : point0.x.d2 ≠ 0, {
          try { simp only [ne.def] },
          try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
          try { dsimp [cast_EcPoint, cast_BigInt3] },
          try { arith_simps }, try { simp only [hcond] },
          try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
        },
        try { dsimp at a4 }, try { arith_simps at a4 },
        clear hcond,
        -- Use the block soundness theorem.
        apply ensuresb_ret_trans (auto_sound_fast_ec_add_block5 mem σ _ range_check_ptr point0 point1 h_mem_rec h_mem_4 h_mem_5 h_mem_6 h_mem_7 h_mem_13 hin_range_check_ptr hin_point0 hin_point1 νbound),
        intros κ_block5 τ, try { arith_simps },
        intro h_block5,
        rcases h_block5 with ⟨rc_m_block5, rc_m_le_block5, hblk_range_check_ptr₁, h_block5⟩,
        -- range check condition
        use_only (rc_m_block5+0+0), split,
        linarith [rc_m_le_block5],
        split,
        { arith_simps, try { simp only [hblk_range_check_ptr₁] },
          try { arith_simps, refl <|> norm_cast }, try { refl } },
        intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
        have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
        -- Final Proof
        -- user-provided reduction
        suffices auto_spec: auto_spec_fast_ec_add mem _ range_check_ptr point0 point1 _ _,
        { apply sound_fast_ec_add, apply auto_spec },
        -- prove the auto generated assertion
        dsimp [auto_spec_fast_ec_add],
        try { norm_num1 }, try { arith_simps },
        left,
        use_only [a0],
        left,
        use_only [a2],
        right,
        use_only [a4],
        have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
        have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
        have h_block5' := h_block5 rc_h_range_check_ptr',
        try { rw [←hin_range_check_ptr] at h_block5' },
        try { dsimp at h_block5, arith_simps at h_block5' },
        have h_block5 := h_block5',
        use_only[κ_block5],
        use [h_block5],
        try { linarith }
      }
    },
    {
      -- if: negative branch
      have a2 : point0.x.d1 ≠ 0, {
        try { simp only [ne.def] },
        try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
        try { dsimp [cast_EcPoint, cast_BigInt3] },
        try { arith_simps }, try { simp only [hcond] },
        try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
      },
      try { dsimp at a2 }, try { arith_simps at a2 },
      clear hcond,
      -- Use the block soundness theorem.
      apply ensuresb_ret_trans (auto_sound_fast_ec_add_block5 mem σ _ range_check_ptr point0 point1 h_mem_rec h_mem_4 h_mem_5 h_mem_6 h_mem_7 h_mem_13 hin_range_check_ptr hin_point0 hin_point1 νbound),
      intros κ_block5 τ, try { arith_simps },
      intro h_block5,
      rcases h_block5 with ⟨rc_m_block5, rc_m_le_block5, hblk_range_check_ptr₁, h_block5⟩,
      -- range check condition
      use_only (rc_m_block5+0+0), split,
      linarith [rc_m_le_block5],
      split,
      { arith_simps, try { simp only [hblk_range_check_ptr₁] },
        try { arith_simps, refl <|> norm_cast }, try { refl } },
      intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
      have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
      -- Final Proof
      -- user-provided reduction
      suffices auto_spec: auto_spec_fast_ec_add mem _ range_check_ptr point0 point1 _ _,
      { apply sound_fast_ec_add, apply auto_spec },
      -- prove the auto generated assertion
      dsimp [auto_spec_fast_ec_add],
      try { norm_num1 }, try { arith_simps },
      left,
      use_only [a0],
      right,
      use_only [a2],
      have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
      have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
      have h_block5' := h_block5 rc_h_range_check_ptr',
      try { rw [←hin_range_check_ptr] at h_block5' },
      try { dsimp at h_block5, arith_simps at h_block5' },
      have h_block5 := h_block5',
      use_only[κ_block5],
      use [h_block5],
      try { linarith }
    }
  },
  {
    -- if: negative branch
    have a0 : point0.x.d0 ≠ 0, {
      try { simp only [ne.def] },
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_point0, hin_point1] },
      try { dsimp [cast_EcPoint, cast_BigInt3] },
      try { arith_simps }, try { simp only [hcond] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a0 }, try { arith_simps at a0 },
    clear hcond,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (auto_sound_fast_ec_add_block5 mem σ _ range_check_ptr point0 point1 h_mem_rec h_mem_4 h_mem_5 h_mem_6 h_mem_7 h_mem_13 hin_range_check_ptr hin_point0 hin_point1 νbound),
    intros κ_block5 τ, try { arith_simps },
    intro h_block5,
    rcases h_block5 with ⟨rc_m_block5, rc_m_le_block5, hblk_range_check_ptr₁, h_block5⟩,
    -- range check condition
    use_only (rc_m_block5+0+0), split,
    linarith [rc_m_le_block5],
    split,
    { arith_simps, try { simp only [hblk_range_check_ptr₁] },
      try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
    have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
    -- Final Proof
    -- user-provided reduction
    suffices auto_spec: auto_spec_fast_ec_add mem _ range_check_ptr point0 point1 _ _,
    { apply sound_fast_ec_add, apply auto_spec },
    -- prove the auto generated assertion
    dsimp [auto_spec_fast_ec_add],
    try { norm_num1 }, try { arith_simps },
    right,
    use_only [a0],
    have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
    have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
    have h_block5' := h_block5 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at h_block5' },
    try { dsimp at h_block5, arith_simps at h_block5' },
    have h_block5 := h_block5',
    use_only[κ_block5],
    use [h_block5],
    try { linarith }
  }
end

