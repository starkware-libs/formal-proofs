/-
File: squash_dict_assert_lt_felt_soundness.lean

Autogenerated file.
-/
import starkware.cairo.lean.semantics.soundness.hoare
import .squash_dict_code
import ..squash_dict_spec
import .squash_dict_assert_le_felt_soundness
open tactic

open starkware.cairo.common.math

variables {F : Type} [field F] [decidable_eq F] [prelude_hyps F]
variable  mem : F → F
variable  σ : register_state F

/- starkware.cairo.common.math.assert_lt_felt autogenerated soundness theorem -/

theorem auto_sound_assert_lt_felt_block3
    -- arguments
    (range_check_ptr a b : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_assert_lt_felt σ.pc)
    -- all dependencies are in memory
    (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 45))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 5))
    (hin_a : a = mem (σ.fp - 4))
    (hin_b : b = mem (σ.fp - 3))
    (νbound : ℕ)
    -- conclusion
  : ensuresb_ret νbound mem
    {pc := σ.pc + 5, ap := σ.ap + 1, fp := σ.fp}
    (λ κ τ,
      τ.ap = σ.ap + 21 ∧
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 5)) (mem $ τ.ap - 1)
        (auto_spec_assert_lt_felt_block3 mem κ range_check_ptr a b (mem (τ.ap - 1)))) :=
begin
  have h_mem_rec := h_mem,
  unpack_memory code_assert_lt_felt at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10⟩,
  -- function call
  step_assert_eq hpc5 with arg0,
  step_assert_eq hpc6 with arg1,
  step_assert_eq hpc7 with arg2,
  step_sub hpc8 (auto_sound_assert_le_felt mem _ range_check_ptr a b _ _ _ _),
  { rw hpc9, norm_num2, exact h_mem_0 },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  { try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b] },
    try { arith_simps }, try { simp only [arg0, arg1, arg2] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  intros κ_call10 ap10 h_call10,
  rcases h_call10 with ⟨h_call10_ap_offset, h_call10⟩,
  rcases h_call10 with ⟨rc_m10, rc_mle10, hl_range_check_ptr₁, h_call10⟩,
  mkdef htv_range_check_ptr₁ : range_check_ptr₁ = (mem (ap10 - 1)),
  simp only [←htv_range_check_ptr₁] at h_call10,
  try { simp only [arg0 ,arg1 ,arg2] at hl_range_check_ptr₁ },
  try { rw [←htv_range_check_ptr₁] at hl_range_check_ptr₁ }, try { rw [←hin_range_check_ptr] at hl_range_check_ptr₁ },
  try { simp only [arg0 ,arg1 ,arg2] at h_call10 },
  rw [hin_range_check_ptr] at h_call10,
  clear arg0 arg1 arg2,
  -- return
  step_ret hpc10,
  -- finish
  step_done, use_only [rfl, rfl],
  split,
  { try { simp only [h_call10_ap_offset] },
    try { arith_simps }, try { refl } },
  -- range check condition
  use_only (rc_m10+0+0), split,
  linarith [rc_mle10],
  split,
  { try { norm_num1 }, arith_simps,
    try { rw [←htv_range_check_ptr₁] }, try { rw [hl_range_check_ptr₁] }, try { rw [hin_range_check_ptr] },
    try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
  intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
  have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
  -- Final Proof
  dsimp [auto_spec_assert_lt_felt_block3],
  try { norm_num1 }, try { arith_simps },
  use_only [κ_call10],
  use_only [range_check_ptr₁],
  have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
  have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
  have spec10 := h_call10 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at spec10 }, try { rw [←htv_range_check_ptr₁] at spec10 },
  try { dsimp at spec10, arith_simps at spec10 },
  use_only [spec10],
  try { split, trivial <|> linarith },
  try { ensures_simps; try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b, htv_range_check_ptr₁] }, },
  try { simp only [h_call10_ap_offset] },
  try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
end

theorem auto_sound_assert_lt_felt
    -- arguments
    (range_check_ptr a b : F)
    -- code is in memory at σ.pc
    (h_mem : mem_at mem code_assert_lt_felt σ.pc)
    -- all dependencies are in memory
    (h_mem_0 : mem_at mem code_assert_le_felt (σ.pc  - 45))
    -- input arguments on the stack
    (hin_range_check_ptr : range_check_ptr = mem (σ.fp - 5))
    (hin_a : a = mem (σ.fp - 4))
    (hin_b : b = mem (σ.fp - 3))
    -- conclusion
  : ensures_ret mem σ (λ κ τ,
      τ.ap = σ.ap + 21 ∧
      ∃ μ ≤ κ, rc_ensures mem (rc_bound F) μ (mem (σ.fp - 5)) (mem $ τ.ap - 1)
        (spec_assert_lt_felt mem κ range_check_ptr a b (mem (τ.ap - 1)))) :=
begin
  apply ensures_of_ensuresb, intro νbound,
  have h_mem_rec := h_mem,
  unpack_memory code_assert_lt_felt at h_mem with ⟨hpc0, hpc1, hpc2, hpc3, hpc4, hpc5, hpc6, hpc7, hpc8, hpc9, hpc10⟩,
  -- if statement
  step_assert_eq hpc0 with temp0,
  have htest: _ = a - b, {
    apply eq.trans (eq_sub_of_eq_add temp0),
    try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b] },
    try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } }, },
  clear temp0,
  step_jnz hpc1 hpc2 with hcond hcond,
  {
    -- if: positive branch
    have a0 := cond_aux1 htest hcond,
    try { arith_simps at a0 },
    clear htest hcond,
    -- assert eq
    step_assert_eq hpc3 hpc4 with temp0,
    have a3: a = a + 1, {
      apply assert_eq_reduction temp0,
      try { simp only [add_neg_eq_sub, hin_range_check_ptr, hin_a, hin_b] },
      try { arith_simps; try { split }; triv <|> refl <|> simp <|> abel; try { norm_num } },
    },
    try { dsimp at a3 }, try { arith_simps at a3 },
    clear temp0,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (auto_sound_assert_lt_felt_block3 mem σ range_check_ptr a b h_mem_rec h_mem_0 hin_range_check_ptr hin_a hin_b νbound),
    intros κ_block3 τ, try { arith_simps },
    rintros ⟨apeq, h_block3⟩,
    use_only [apeq],
    rcases h_block3 with ⟨rc_m_block3, rc_m_le_block3, hblk_range_check_ptr₁, h_block3⟩,
    -- range check condition
    use_only (rc_m_block3+0+0), split,
    linarith [rc_m_le_block3],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hblk_range_check_ptr₁] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
    have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
    -- Final Proof
    -- user-provided reduction
    suffices auto_spec: auto_spec_assert_lt_felt mem _ range_check_ptr a b _,
    { apply sound_assert_lt_felt, apply auto_spec },
    -- prove the auto generated assertion
    dsimp [auto_spec_assert_lt_felt],
    try { norm_num1 }, try { arith_simps },
    left,
    use_only [a0],
    use_only [a3],
    have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
    have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
    have h_block3' := h_block3 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at h_block3' },
    try { dsimp at h_block3, arith_simps at h_block3' },
    have h_block3 := h_block3',
    use_only [κ_block3],
    use [h_block3],
    try { linarith }
  },
  {
    -- if: negative branch
    have a0 := cond_aux2 htest hcond,
    try { arith_simps at a0 },
    clear htest hcond,
    -- Use the block soundness theorem.
    apply ensuresb_ret_trans (auto_sound_assert_lt_felt_block3 mem σ range_check_ptr a b h_mem_rec h_mem_0 hin_range_check_ptr hin_a hin_b νbound),
    intros κ_block3 τ, try { arith_simps },
    rintros ⟨apeq, h_block3⟩,
    use_only [apeq],
    rcases h_block3 with ⟨rc_m_block3, rc_m_le_block3, hblk_range_check_ptr₁, h_block3⟩,
    -- range check condition
    use_only (rc_m_block3+0+0), split,
    linarith [rc_m_le_block3],
    split,
    { try { norm_num1 }, arith_simps, try { simp only [hblk_range_check_ptr₁] },
      try { ring_nf }, try { arith_simps, refl <|> norm_cast }, try { refl } },
    intro rc_h_range_check_ptr, repeat { rw [add_assoc] at rc_h_range_check_ptr },
    have rc_h_range_check_ptr' := range_checked_add_right rc_h_range_check_ptr,
    -- Final Proof
    -- user-provided reduction
    suffices auto_spec: auto_spec_assert_lt_felt mem _ range_check_ptr a b _,
    { apply sound_assert_lt_felt, apply auto_spec },
    -- prove the auto generated assertion
    dsimp [auto_spec_assert_lt_felt],
    try { norm_num1 }, try { arith_simps },
    right,
    use_only [a0],
    have rc_h_range_check_ptr₁ := range_checked_offset' rc_h_range_check_ptr,
    have rc_h_range_check_ptr₁' := range_checked_add_right rc_h_range_check_ptr₁, try { norm_cast at rc_h_range_check_ptr₁' },
    have h_block3' := h_block3 rc_h_range_check_ptr',
    try { rw [←hin_range_check_ptr] at h_block3' },
    try { dsimp at h_block3, arith_simps at h_block3' },
    have h_block3 := h_block3',
    use_only [κ_block3],
    use [h_block3],
    try { linarith }
  }
end

