/-
This file translates the autogenerated data and constraints to the form used in the formalization.
-/
import starkware.cairo.lean.semantics.air_encoding.constraints_autogen
import starkware.cairo.lean.semantics.air_encoding.constraints
import starkware.cairo.lean.semantics.air_encoding.memory
import starkware.cairo.lean.semantics.air_encoding.range_check

open_locale classical big_operators

noncomputable theory

variables {F : Type*} [field F] [fintype F]

/- interpreting instruction constraints -/

def cpu__decode.to_instruction_constraints {c : columns F} (cd : cpu__decode c)
    (j : nat) :
  instruction_constraints
    (c.cpu__decode__instruction (j * 16))                          -- inst
    (c.cpu__decode__off1 (j * 16))                                 -- off_op0_tilde
    (c.cpu__decode__off2 (j * 16))                                 -- off_op1_tilde
    (c.cpu__decode__off0 (j * 16))                                 -- off_dst_tilde
    (λ k : fin 16, c.cpu__decode__opcode_rc__column (j * 16 + k))  -- f_tilde
    :=
{ h_instruction :=
    begin
      dsimp,
      have := cd.opcode_rc_input (j * 16) (by simp),
      rw [eq_of_sub_eq_zero this, add_zero],
      ring
    end,
  h_bit :=
    begin
      intro k, dsimp [tilde_type.to_f, column.off],
      have : ↑(k.succ) = ↑k + 1, by simp,
      rw [this, mul_sub, add_zero, add_zero, ←add_assoc, mul_one],
      have : ¬(j * 16 + ↑k) % 16 = 15,
      { rw [add_comm, nat.add_mul_mod_self_right], apply ne_of_lt,
        have kprop := k.prop,
        rw ← nat.mod_eq_of_lt (lt_trans k.prop (nat.lt_succ_self _)) at kprop,
        exact kprop },
      have h := cd.opcode_rc__bit (j * 16 + k) this,
      rw [←two_mul, column.off] at h,
      exact h,
    end,
  h_last_value :=
    begin
      dsimp,
      have : (j * 16 + 15) % 16 = 15,
      { rw [add_comm, nat.add_mul_mod_self_right, nat.mod_eq_of_lt (nat.lt_succ_self _)] },
      exact cd.opcode_rc__zero (j * 16 + 15) this
    end }

 /- interpreting execution step constraints -/

def cpu__operands.to_step_constraints {c : columns F} {inp : input_data F} (ops : cpu__operands c)
    (upd : cpu__update_registers inp c) (opcodes : cpu__opcodes c)
    (j : ℕ) (hj : j ≠ inp.trace_length / 16 - 1) :
  step_constraints
    (c.cpu__decode__off1 (j * 16))                                 -- off_op0_tilde
    (c.cpu__decode__off2 (j * 16))                                 -- off_op1_tilde
    (c.cpu__decode__off0 (j * 16))                                 -- off_dst_tilde
    (λ k : fin 16, c.cpu__decode__opcode_rc__column (j * 16 + k))  -- f_tilde
    (c.cpu__registers__fp (j * 16))                                -- fp
    (c.cpu__registers__ap (j * 16))                                -- ap
    (c.cpu__decode__pc (j * 16))                                   -- pc
    (c.cpu__registers__fp ((j + 1) * 16))                          -- next fp
    (c.cpu__registers__ap ((j + 1) * 16))                          -- next ap
    (c.cpu__decode__pc ((j + 1) * 16))                             -- next pc
    (c.cpu__operands__mem_dst__addr (j * 16))                      -- dst_addr
    (c.cpu__operands__mem_op0__addr (j * 16))                      -- op0_addr
    (c.cpu__operands__mem_op1__addr (j * 16))                      -- op1_addr
    (c.cpu__operands__mem_dst__value (j * 16))                     -- dst
    (c.cpu__operands__mem_op0__value (j * 16))                     -- op0
    (c.cpu__operands__mem_op1__value (j * 16))                     -- op1
    :=
have h0 : (j * 16 % 16 = 0), by simp,
have h1 : ¬ (j * 16 = 16 * (inp.trace_length / 16 - 1)),
  by { rwa [mul_comm, mul_right_inj' _], norm_num },
{ mul := c.cpu__operands__ops_mul (j * 16),
  res := c.cpu__operands__res (j * 16),
  t0 := c.cpu__update_registers__update_pc__tmp0 (j * 16),
  t1 := c.cpu__update_registers__update_pc__tmp1 (j * 16),
  h_dst_addr :=
    begin
      simp [tilde_type.f_dst_reg, tilde_type.to_f, column.off, two_mul],
      have h := ops.mem_dst_addr _ h0,
      simp [column.off] at h,
      rw [sub_eq_zero] at h,
      rw ←sub_eq_iff_eq_add.mpr h.symm,
      ring
    end,
  h_op0_addr :=
    begin
      simp [tilde_type.f_op0_reg, tilde_type.to_f, column.off, two_mul],
      have h := ops.mem0_addr _ h0,
      simp [column.off] at h,
      rw [sub_eq_zero] at h,
      rw ←sub_eq_iff_eq_add.mpr h.symm,
      ring
    end,
  h_op1_addr :=
    begin
      have coe3 : ↑(3 : fin 15) = 3 := fin.coe_eq_val _,
      have coe4 : ↑(4 : fin 15) = 4 := fin.coe_eq_val _,
      simp [tilde_type.f_op1_imm, tilde_type.f_op1_ap, tilde_type.f_op1_fp,
        tilde_type.to_f, column.off, two_mul, coe3, coe4],
      have h := ops.mem1_addr _ h0,
      simp [column.off] at h,
      rw [sub_eq_zero] at h,
      rw ←sub_eq_iff_eq_add.mpr h.symm,
      ring,
    end,
  h_mul := eq_of_sub_eq_zero (ops.ops_mul _ h0),
  h_res :=
    begin
      have coe5 : ↑(5 : fin 15) = 5 := fin.coe_eq_val _,
      have coe6 : ↑(6 : fin 15) = 6 := fin.coe_eq_val _,
      have coe9 : ↑(9 : fin 15) = 9 := fin.coe_eq_val _,
      simp [tilde_type.f_pc_jnz, tilde_type.f_res_add, tilde_type.f_res_mul,
        tilde_type.to_f, column.off, coe5, coe6, coe9, two_mul],
      have h := ops.res _ h0,
      rw [sub_eq_zero] at h,
      transitivity,
      apply h,
      norm_num, ring,
    end,
  h_t0_eq :=
    begin
      simp [tilde_type.f_pc_jnz, tilde_type.to_f, column.off, two_mul],
      exact eq_of_sub_eq_zero (upd.update_pc__tmp0 _ ⟨h0, h1⟩)
    end,
  h_t1_eq := eq_of_sub_eq_zero (upd.update_pc__tmp1 _ ⟨h0, h1⟩),
  h_next_pc_eq :=
    begin
      have coe9 : ↑(9 : fin 15) = 9 := fin.coe_eq_val _,
      dsimp,
      simp only [tilde_type.f_pc_jnz, tilde_type.f_op1_imm, tilde_type.to_f, column.off, coe9,
        two_mul, add_zero, fin.coe_two, fin.coe_succ, fin.coe_cast_succ, add_mul],
      have h := upd.update_pc__pc_cond_positive _ ⟨h0, h1⟩,
      convert h using 2,
      simp [column.off], ring
    end,
  h_next_pc_eq' :=
    begin
      dsimp,
      have coe7 : ↑(7 : fin 15) = 7 := fin.coe_eq_val _,
      have coe8 : ↑(8 : fin 15) = 8 := fin.coe_eq_val _,
      have coe9 : ↑(9 : fin 15) = 9 := fin.coe_eq_val _,
      rw ←upd.update_pc__pc_cond_negative _ ⟨h0, h1⟩,
      simp [tilde_type.f_pc_jnz, tilde_type.f_pc_jump_abs, tilde_type.f_pc_jump_rel,
        tilde_type.f_op1_imm, tilde_type.to_f, column.off, coe7, coe8, coe9,
        two_mul, add_zero, add_mul, fin.coe_two, fin.coe_succ, fin.coe_cast_succ],
      ring
    end,
  h_opcode_call :=
    begin
      rw ←opcodes.call__push_fp _ h0,
      dsimp,
      simp only [tilde_type.f_opcode_call, tilde_type.to_f, column.off, add_zero, fin.coe_succ,
        fin.coe_cast_succ, ←two_mul],
      refl
    end,
  h_opcode_call' :=
    begin
      have coe12 : ↑(12 : fin 15) = 12 := fin.coe_eq_val _,
      rw ←opcodes.call__push_pc _ h0,
      dsimp,
      simp only [tilde_type.f_opcode_call, tilde_type.f_op1_imm, tilde_type.to_f, column.off,
        add_zero, fin.coe_succ, fin.coe_cast_succ, ←two_mul, coe12],
      ring
    end,
  h_opcode_assert_eq :=
    begin
      have coe14 : ↑(14 : fin 15) = 14 := fin.coe_eq_val _,
      rw ←opcodes.assert_eq__assert_eq _ h0,
      dsimp,
      simp only [tilde_type.f_opcode_assert_eq, tilde_type.to_f, column.off, add_zero, fin.coe_succ,
        fin.coe_cast_succ, ←two_mul, coe14]
    end,
  h_next_ap :=
    begin
      have coe10 : ↑(10 : fin 15) = 10 := fin.coe_eq_val _,
      have coe11 : ↑(11 : fin 15) = 11 := fin.coe_eq_val _,
      have coe12 : ↑(12 : fin 15) = 12 := fin.coe_eq_val _,
      dsimp,
      simp only [add_mul, one_mul, column.off, add_zero],
      transitivity,
      { exact eq_of_sub_eq_zero (upd.update_ap__ap_update _ ⟨h0, h1⟩) },
      simp only [tilde_type.f_opcode_call, tilde_type.f_ap_add, tilde_type.f_ap_add1,
        tilde_type.to_f, column.off, fin.coe_succ, fin.coe_cast_succ, coe10, coe11, coe12,
        ←two_mul],
      norm_num, ring
    end,
  h_next_fp :=
    begin
      have coe12 : ↑(12 : fin 15) = 12 := fin.coe_eq_val _,
      have coe13 : ↑(13 : fin 15) = 13 := fin.coe_eq_val _,
      dsimp,
      simp only [add_mul, one_mul, column.off, add_zero],
      transitivity,
      { exact eq_of_sub_eq_zero (upd.update_fp__fp_update _ ⟨h0, h1⟩) },
      simp only [tilde_type.f_opcode_call, tilde_type.f_opcode_ret,
        tilde_type.to_f, column.off, fin.coe_succ, fin.coe_cast_succ,
        coe12, coe13, ←two_mul],
      norm_num, ring
    end }

/-
interpreting range check constraints

Note: there are inp.trace_length / 16 - 1 steps (so the execution trace, including
the last step, has length inp.trace_length / 16), but there are inp.trace_length / 16
many 16-bit range-checked elements.
-/

def rc16.to_range_check_constraints
  {c : columns F}
  {ci : columns_inter F}
  {inp : input_data F}
  {pd : public_data F}
  (rc16 : rc16 inp pd c ci)
  (trace_length_pos : inp.trace_length > 0)
  (public_memory_prod_eq_one : pd.rc16__perm__public_memory_prod = 1)
  (trace_length_le_char : inp.trace_length ≤ ring_char F) :
  range_check_constraints
    (inp.trace_length / 16 - 1)                               -- T
    (inp.trace_length / 16)                                   -- rc16_len
    (λ j, c.cpu__decode__off1 (j * 16))                       -- off_op0_tilde : fin T → F
    (λ j, c.cpu__decode__off2 (j * 16))                       -- off_op1_tilde : fin T → F
    (λ j, c.cpu__decode__off0 (j * 16))                       -- off_dst_tilde : fin T → F
    (λ j, c.rc_builtin__inner_rc (j * 16))                    -- rc16_val      : fin rc16_len → F
    pd.rc_min
    pd.rc_max :=
have h : ∀ j : ℕ, ∀ i : fin (inp.trace_length / 16 - 1),
           j < 16 → (↑i * 16 + j) < inp.trace_length - 1 + 1,
  begin
    rintros j ⟨i, ilt⟩ jlt,
    rw nat.sub_add_cancel trace_length_pos,
    apply lt_of_lt_of_le (add_lt_add_left jlt _),
    suffices : (i + 1) * 16 ≤ inp.trace_length, by rwa [add_mul] at this,
    apply le_trans (nat.mul_le_mul_right _ _) (nat.div_mul_le_self _ 16),
    exact lt_of_lt_of_le ilt (nat.pred_le _)
  end,
have h' : ∀ j : ℕ, ∀ i : fin (inp.trace_length / 16),
           j < 16 → (↑i * 16 + j) < inp.trace_length - 1 + 1,
  begin
    rintros j ⟨i, ilt⟩ jlt,
    rw nat.sub_add_cancel trace_length_pos,
    apply lt_of_lt_of_le (add_lt_add_left jlt _),
    suffices : (i + 1) * 16 ≤ inp.trace_length, by rwa [add_mul] at this,
    apply le_trans (nat.mul_le_mul_right _ _) (nat.div_mul_le_self _ 16),
    exact nat.succ_le_of_lt ilt
  end,
{ n  := inp.trace_length - 1,
  a  := λ i, c.rc16_pool i,
  a' := λ i, c.rc16__sorted i,
  p  := λ i, ci.rc16__perm__cum_prod0 i,
  z  := pd.rc16__perm__interaction_elm,
  embed_off_op0 := λ i, ⟨↑i * 16 + 8, h 8 i (by norm_num)⟩,
  embed_off_op1 := λ i, ⟨↑i * 16 + 4, h 4 i (by norm_num)⟩,
  embed_off_dst := λ i, ⟨↑i * 16, h 0 i (by norm_num)⟩,
  embed_rc16_vals := λ i, ⟨↑i * 16 + 12, h' 12 i (by norm_num)⟩,
  h_embed_op0   := λ i, rfl,
  h_embed_op1   := λ i, rfl,
  h_embed_dst   := λ i, rfl,
  h_embed_rc16  := λ i, rfl,
  h_continuity  :=
    begin
      intro i,
      rw [←rc16.diff_is_bit _ (ne_of_lt i.is_lt), mul_sub, mul_one],
      simp, refl
    end,
  h_initial :=
    begin
      rw [←sub_eq_zero, ←rc16.perm__init0 _ rfl],
      simp [column.off], abel
    end,
  h_cumulative :=
    begin
      intro i,
      rw [←sub_eq_zero, ←rc16.perm__step0 _ (ne_of_lt i.is_lt)],
      simp [column.off]
    end,
  h_final  := (eq_of_sub_eq_zero (rc16.perm__last _ rfl)).trans public_memory_prod_eq_one,
  h_rc_min := eq_of_sub_eq_zero $ rc16.minimum _ rfl,
  h_rc_max := eq_of_sub_eq_zero $ rc16.maximum _ rfl,
  h_n_lt   :=
    begin
      apply nat.lt_of_succ_le,
      rw [nat.succ_eq_add_one, nat.sub_add_cancel trace_length_pos],
      exact trace_length_le_char
    end }

/- interpreting memory constraints -/

def memory.to_memory_block_constraints
    {inp : input_data F} {pd : public_data F} {c : columns F} {ci : columns_inter F}
    (h_mem_star :
      let z     := pd.memory__multi_column_perm__perm__interaction_elm,
          alpha := pd.memory__multi_column_perm__hash_interaction_elm0,
          p     := pd.memory__multi_column_perm__perm__public_memory_prod,
          dom_m_star := { x // option.is_some (inp.m_star x) } in
       p * ∏ a : dom_m_star, (z - (a.val + alpha * mem_val a)) = z^(fintype.card dom_m_star))
    (m : memory inp pd c ci) :
  memory_block_constraints
    (inp.trace_length / 2 - 1)         -- n
    (λ i, c.mem_pool__addr (2 * i))    -- a
    (λ i, c.mem_pool__value (2 * i))   -- v
    inp.m_star
    :=
have h0 : ∀ j : fin (inp.trace_length / 2 - 1), ↑j * 2 % 2 = 0, by intro j; simp,
have h1 : ∀ j : fin (inp.trace_length / 2 - 1), ¬ (↑j * 2 = 2 * (inp.trace_length / 2 - 1)),
  begin
    rintros ⟨j, jlt⟩,
    have hj : j ≠ inp.trace_length / 2 - 1 := ne_of_lt jlt,
    rwa [mul_comm, mul_right_inj' _], norm_num
  end,
{ a'    := (λ j, c.column20 (2 * j)),
  v'    := (λ j, c.column20 (2 * j + 1)),
  p     := (λ j, ci.column24_inter1 (2 * j)),
  alpha := pd.memory__multi_column_perm__hash_interaction_elm0,
  z     := pd.memory__multi_column_perm__perm__interaction_elm,
  h_continuity :=
    begin
      intro j,
      rw [←m.diff_is_bit (↑j * 2) ⟨h0 j, h1 j⟩, mul_comm 2],
      simp [column.off, add_mul, mul_comm 2], ring
    end,
  h_single_valued :=
    begin
      intro j,
      apply neg_inj.mp,
      rw [neg_zero, ←m.is_func (↑j * 2) ⟨h0 j, h1 j⟩],
      simp [column.off, add_mul, mul_add, mul_comm 2, add_assoc], norm_num,
      ring
    end,
  h_initial :=
    begin
      rw [←sub_eq_zero, ←m.multi_column_perm__perm__init0 _ rfl],
      simp [column.off], ring
    end,
  h_cumulative :=
    begin
      intro j,
      rw [←sub_eq_zero, ←m.multi_column_perm__perm__step0 (↑j * 2) ⟨h0 j, h1 j⟩],
      simp [column.off, add_mul, mul_add, mul_comm 2, add_assoc]
    end,
  h_final :=
    begin
      apply eq.trans _ h_mem_star,
      rw [←eq_of_sub_eq_zero (m.multi_column_perm__perm__last _ rfl)],
      refl
    end }

/- interpreting range check builtin constraints -/

/-- Use 8 16-bit range-checked elements for each 128-bit range-checked element -/
def rc_to_rc16 {inp : input_data F} :
  fin (inp.trace_length / 128) → fin 8 → fin (inp.trace_length / 16) :=
λ i j, ⟨i * 8 + j,
  begin
    cases i with i hi,
    cases j with j hj,
    calc
      ↑i * 8 + ↑j < (i + 1) * 8 :
        by { rw [add_mul, one_mul], apply add_lt_add_left hj }
      ... = ((i + 1) * 8 * 16) / 16 :
        by { rw nat.mul_div_cancel, norm_num }
      ... ≤ inp.trace_length / 16 :
        by { apply nat.div_le_div_right, rw mul_assoc, norm_num,
              rw ← nat.le_div_iff_mul_le, exact nat.succ_le_of_lt hi, norm_num }
  end⟩

def rc_builtin.to_rc_builtin_constraints
    {inp : input_data F} {pd : public_data F} {c : columns F}
    (rcb : rc_builtin inp pd c) :
  rc_builtin_constraints
    (inp.trace_length / 16)
    (pd.initial_rc_addr)
    (inp.trace_length / 128)
    (λ j, c.rc_builtin__inner_rc (j * 16))
    (λ j, c.rc_builtin__mem__addr (j * 128))
    (λ j, c.rc_builtin__mem__value (j * 128))
    rc_to_rc16 :=
{ h_rc_init_addr := λ h, eq_of_sub_eq_zero (rcb.init_addr _ rfl),
  h_rc_addr_step :=
    begin
      intros i hi,
      have := rcb.addr_step (i * 128),
      simp [column.off, nat.succ_eq_add_one, add_mul, one_mul, add_assoc],
      norm_num,
      convert eq_of_sub_eq_zero (this _), simp,
      rw [mul_comm _ 128, mul_left_cancel_iff_of_pos (show 0 < 128, by norm_num)],
      contrapose! hi,
      rw [hi, nat.succ_eq_add_one],
      apply le_tsub_add
    end,
  h_rc_value :=
    begin
      intro i,
      have := rcb.value (i * 128),
      simp at this,
      rw [columns.rc_builtin__mem__value, ←eq_of_sub_eq_zero this],
      simp only [rc_to_rc16, column.off, columns.rc_builtin__inner_rc],
      iterate 14 { congr' 1 };
       { simp [column.off, add_mul, mul_assoc], congr' 1, try { norm_num } }
    end   }

theorem card_dom_aux {inp : input_data F}
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length) :
  4 * fintype.card { x // option.is_some (inp.m_star x) } ≤ inp.trace_length / 2 - 1 :=
begin
  apply nat.le_pred_of_lt,
  apply nat.lt_of_succ_le,
  rw [nat.le_div_iff_mul_le' (show 0 < 2, by norm_num), nat.succ_mul, mul_comm, ←mul_assoc],
  norm_num,
  exact h_card
end

def embed_mem {inp : input_data F}
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
    (a : mem_dom inp.m_star) :
     fin (inp.trace_length / 2 - 1 + 1) :=
let i := (fintype.equiv_fin { x // option.is_some (inp.m_star x) }).to_fun a in
  ⟨4 * i.val + 1,
  nat.succ_lt_succ (lt_of_lt_of_le (nat.mul_lt_mul_of_pos_left i.is_lt (by norm_num))
    (card_dom_aux h_card))⟩

def public_memory.to_memory_embedding_constraints
    {c : columns F} {inp : input_data F}
    (pm : public_memory c)
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length) :
  memory_embedding_constraints
    (inp.trace_length / 16 - 1)                               -- T
    (inp.trace_length / 128)                                  -- rc_len
    (λ j, c.cpu__decode__pc (j * 16))                         -- pc
    (λ j, c.cpu__decode__instruction (j * 16))                -- inst
    (λ j, c.cpu__operands__mem_dst__addr (j * 16))            -- dst_addr
    (λ j, c.cpu__operands__mem_dst__value (j * 16))           -- dst
    (λ j, c.cpu__operands__mem_op0__addr (j * 16))            -- op0_addr
    (λ j, c.cpu__operands__mem_op0__value (j * 16))           -- op0
    (λ j, c.cpu__operands__mem_op1__addr (j * 16))            -- op1_addr
    (λ j, c.cpu__operands__mem_op1__value (j * 16))           -- op1
    (λ j, c.rc_builtin__mem__addr (j * 128))                  -- rc_addr
    (λ j, c.rc_builtin__mem__value (j * 128))                 -- rc
    inp.m_star                                                -- mem_star
    (inp.trace_length / 2 - 1)                                -- n
    (λ i, c.mem_pool__addr (2 * i))                           -- a
    (λ i, c.mem_pool__value (2 * i))                          -- v
    :=
have h : ∀ j : ℕ, ∀ i : fin (inp.trace_length / 16 - 1), j < 8 →
    (↑i * 8 + j) < inp.trace_length / 2 - 1 + 1,
  begin
    rintros j ⟨i, ilt⟩ jlt,
    apply nat.lt_succ_of_le,
    apply nat.le_pred_of_lt,
    have : i * 8 + j < (i + 1) * 8,
    { rw [add_mul, one_mul], exact add_lt_add_left jlt _ },
    apply lt_of_lt_of_le this,
    rw [nat.le_div_iff_mul_le' (show 0 < 2, by norm_num), mul_assoc],
    norm_num,
    rw [←nat.le_div_iff_mul_le' (show 0 < 16, by norm_num)],
    apply nat.succ_le_of_lt,
    exact lt_of_lt_of_le ilt (nat.pred_le _)
  end,
have h1 : ∀ i : fin (inp.trace_length / 128),
    (↑i * 64 + 51) < inp.trace_length / 2 - 1 + 1,
  begin
    rintros ⟨i, ilt⟩,
    apply nat.lt_succ_of_le,
    apply nat.le_pred_of_lt,
    have : i * 64 + 51 < (i + 1) * 64,
    { rw add_mul, apply add_lt_add_left, norm_num },
    apply lt_of_lt_of_le this,
    apply le_trans (nat.mul_le_mul_right _ (nat.succ_le_of_lt ilt)),
    rw [nat.le_div_iff_mul_le' (show 0 < 2, by norm_num), mul_assoc],
    norm_num,
    apply nat.div_mul_le_self
  end,
have jaux : ∀ j : fin (inp.trace_length / 16 - 1), (j : ℕ) * 8 = 4 * (2 * j),
  by { intro j, rw [←mul_assoc, mul_comm (4 * 2)], refl },
{ embed_inst := λ i, ⟨↑i * 8 + 0, h 0 i (by norm_num)⟩,
  embed_dst  := λ i, ⟨↑i * 8 + 4, h 4 i (by norm_num)⟩,
  embed_op0  := λ i, ⟨↑i * 8 + 2, h 2 i (by norm_num)⟩,
  embed_op1  := λ i, ⟨↑i * 8 + 6, h 6 i (by norm_num)⟩,
  embed_rc   := λ i, ⟨↑i * 64 + 51, h1 i⟩,
  embed_mem  := embed_mem h_card,
  h_embed_pc       := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_inst     := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_dst_addr := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_dst      := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_op0_addr := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_op0      := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_op1_addr := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_op1      := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_rc_addr  := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_rc       := by { intro i, dsimp [column.off], congr' 1, ring },
  h_embed_dom      :=
    begin
      intro a, simp [column.off],
      apply pm.addr_zero, simp, rw [←mul_assoc],
      exact nat.mul_mod_right _ _
    end,
  h_embed_val :=
    begin
      intro a, simp [column.off],
      apply pm.value_zero, simp, rw [←mul_assoc],
      exact nat.mul_mod_right _ _
    end,
  h_embed_mem_inj :=
    begin
      intros a1 a2, dsimp [embed_mem],
      rw [fin.eq_iff_veq, add_left_inj 1, mul_right_inj' (show 4 ≠ 0, by norm_num), ←fin.ext_iff],
      apply equiv.injective
    end,
  h_embed_mem_disj_inst :=
    begin
      intros a j h',
      rw [fin.eq_iff_veq] at h', dsimp at h',
      have := congr_arg (λ n, n % 4) h', dsimp [embed_mem] at this,
      rw [add_comm, add_comm _ 0, jaux, nat.add_mul_mod_self_left,
       nat.add_mul_mod_self_left] at this,
      norm_num at this
    end,
  h_embed_mem_disj_dst :=
    begin
      intros a j h',
      rw [fin.eq_iff_veq] at h', dsimp  [embed_mem] at h',
      have := congr_arg (λ n, n % 4) h', dsimp at this,
      rw [add_comm, add_comm _ 4, jaux, nat.add_mul_mod_self_left,
       nat.add_mul_mod_self_left] at this,
      norm_num at this
    end,
  h_embed_mem_disj_op0 :=
    begin
      intros a j h',
      rw [fin.eq_iff_veq] at h', dsimp  [embed_mem] at h',
      have := congr_arg (λ n, n % 4) h', dsimp at this,
      rw [add_comm, add_comm _ 2, jaux, nat.add_mul_mod_self_left,
       nat.add_mul_mod_self_left] at this,
      norm_num at this
    end,
  h_embed_mem_disj_op1 :=
    begin
      intros a j h',
      rw [fin.eq_iff_veq] at h', dsimp  [embed_mem] at h',
      have := congr_arg (λ n, n % 4) h', dsimp at this,
      rw [add_comm, add_comm _ 6, jaux, nat.add_mul_mod_self_left,
       nat.add_mul_mod_self_left] at this,
      norm_num at this
    end,
  h_embed_mem_disj_rc :=
    begin
      intros a j h',
      rw [fin.eq_iff_veq] at h', dsimp  [embed_mem] at h',
      have jaux' : 64 = 16 * 4, by norm_num,
      have := congr_arg (λ n, n % 4) h', dsimp at this,
      rw [add_comm, add_comm _ 51, nat.add_mul_mod_self_left] at this,
      simp only [jaux', ←mul_assoc] at this,
      norm_num at this
    end }

/- putting it all together -/

def input_data.to_input_data_aux (inp : input_data F) (pd : public_data F)
  (rc_max_lt : pd.rc_max < 2^16)
  (rc_min_le : pd.rc_min ≤ pd.rc_max) : input_data_aux F :=
{ T := inp.trace_length / 16 - 1,
  rc16_len := inp.trace_length / 16,
  rc_len := inp.trace_length / 128,
  pc_I := inp.initial_pc,
  pc_F := inp.final_pc,
  ap_I := inp.initial_ap,
  ap_F := inp.final_ap,
  mem_star := inp.m_star,
  rc_min := pd.rc_min,
  rc_max := pd.rc_max,
  initial_rc_addr := pd.initial_rc_addr,
  rc_to_rc16 := rc_to_rc16,
  h_rc_lt := rc_max_lt,
  h_rc_le := rc_min_le }

def to_constraints {inp : input_data F} {pd : public_data F} {c : columns F} {ci : columns_inter F}
    /- autogenerated constraints -/
    (cd      : cpu__decode c)
    (ops     : cpu__operands c)
    (upd     : cpu__update_registers inp c)
    (opcodes : cpu__opcodes c)
    (m       : memory inp pd c ci)
    (rc      : rc16 inp pd c ci)
    (pm      : public_memory c)
    (rcb     : rc_builtin inp pd c)
    (iandf : toplevel_constraints inp c)
    /- extra assumptions -/
    (h_mem_star :
      let z     := pd.memory__multi_column_perm__perm__interaction_elm,
          alpha := pd.memory__multi_column_perm__hash_interaction_elm0,
          p     := pd.memory__multi_column_perm__perm__public_memory_prod,
          dom_m_star := { x // option.is_some (inp.m_star x) } in
       p * ∏ a : dom_m_star, (z - (a.val + alpha * mem_val a)) = z^(fintype.card dom_m_star))
    (h_card_dom : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
    (public_memory_prod_eq_one : pd.rc16__perm__public_memory_prod = 1)
    (rc_max_lt : pd.rc_max < 2^16)
    (rc_min_le : pd.rc_min ≤ pd.rc_max)
    (trace_length_le_char : inp.trace_length ≤ ring_char F) :
  constraints (inp.to_input_data_aux pd rc_max_lt rc_min_le) :=
have trace_length_pos : inp.trace_length > 0,
  from lt_of_lt_of_le (nat.zero_lt_succ _) h_card_dom,
{ fp := λ j, c.cpu__registers__fp (j * 16),
  ap := λ j, c.cpu__registers__ap (j * 16),
  pc := λ j, c.cpu__decode__pc (j * 16),
  inst := λ j, c.cpu__decode__instruction (j * 16),
  off_op0_tilde := λ j, c.cpu__decode__off1 (j * 16),
  off_op1_tilde := λ j, c.cpu__decode__off2 (j * 16),
  off_dst_tilde := λ j, c.cpu__decode__off0 (j * 16),
  rc16_val      := λ j, c.rc_builtin__inner_rc (j * 16),
  f_tilde := λ j k, c.cpu__decode__opcode_rc__column (j * 16 + k),
  dst_addr := λ j, c.cpu__operands__mem_dst__addr (j * 16),
  dst := λ j, c.cpu__operands__mem_dst__value (j * 16),
  op0_addr := λ j, c.cpu__operands__mem_op0__addr (j * 16),
  op0 := λ j, c.cpu__operands__mem_op0__value (j * 16),
  op1_addr := λ j, c.cpu__operands__mem_op1__addr (j * 16),
  op1 := λ j, c.cpu__operands__mem_op1__value (j * 16),
  rc_addr := λj, c.rc_builtin__mem__addr (j * 128),
  rc_val := λj, c.rc_builtin__mem__value (j * 128),
  h_pc_I := eq_of_sub_eq_zero (iandf.initial_pc _ rfl),
  h_ap_I := eq_of_sub_eq_zero (iandf.initial_ap _ rfl),
  h_fp_I := eq_of_sub_eq_zero (iandf.initial_fp _ rfl),
  h_pc_F := by { rw mul_comm _ 16, exact eq_of_sub_eq_zero (iandf.final_pc _ rfl) },
  h_ap_F := by { rw mul_comm _ 16, exact eq_of_sub_eq_zero (iandf.final_ap _ rfl) },
  mc := { n := inp.trace_length / 2 - 1,
          a := λ i, c.mem_pool__addr (2 * i),
          v := λ i, c.mem_pool__value (2 * i),
          em := pm.to_memory_embedding_constraints h_card_dom,
          mb := m.to_memory_block_constraints h_mem_star,
          h_n_lt :=
            begin
              apply lt_of_lt_of_le _ trace_length_le_char,
              apply nat.lt_of_succ_le,
              rw [nat.sub_one, nat.succ_pred_eq_of_pos],
              { apply  nat.div_le_self },
              apply nat.div_pos _ (show 0 < 2, by norm_num),
              apply le_trans _ h_card_dom,
              apply le_add_left (le_refl _),
            end},
  rc := rc.to_range_check_constraints trace_length_pos public_memory_prod_eq_one
          trace_length_le_char,
  ic := λ i, cd.to_instruction_constraints i,
  sc := λ i, by { rw fin.coe_succ, exact ops.to_step_constraints upd opcodes i (ne_of_lt i.is_lt) },
  rcb := rcb.to_rc_builtin_constraints
}

/- probabilistic constraints -/

def bad1 {inp : input_data F}
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
    (c19 c20 : column F) : finset F :=
bad_set_1
  (real_a inp.m_star (λ i, c19 (2 * i))     (embed_mem h_card))
  (real_v inp.m_star (λ i, c19 (2 * i + 1)) (embed_mem h_card))
  (λ j, c20 (2 * ↑j))
  (λ j, c20 (2 * ↑j + 1))

def bad2 {inp : input_data F} (pd : public_data F)
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
    (c19 c20 : column F) : finset F :=
bad_set_2
  (real_a inp.m_star (λ i, c19 (2 * i))     (embed_mem h_card))
  (real_v inp.m_star (λ i, c19 (2 * i + 1)) (embed_mem h_card))
  (λ j, c20 (2 * ↑j))
  (λ j, c20 (2 * ↑j + 1))
  pd.memory__multi_column_perm__hash_interaction_elm0

def bad3 (inp : input_data F) (c0 c2 : column F) : finset F :=
bad_set_3
  (λ (i : fin (inp.trace_length - 1 + 1)), c0 i)
  (λ (i : fin (inp.trace_length - 1 + 1)), c2 i)

lemma trace_length_div_two_pos {inp : input_data F}
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length) :
  inp.trace_length / 2 > 0 :=
begin
  apply nat.div_pos _ (show 0 < 2, by norm_num),
  apply le_trans _ h_card,
  apply le_add_left (le_refl _)
end

theorem bad1_bound {inp : input_data F}
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
    (c19 c20 : column F) :
  (bad1 h_card c19 c20).card ≤ (inp.trace_length / 2)^2 :=
begin
  transitivity,
  apply card_bad_set_1_le,
  rw [nat.sub_add_cancel, pow_two],
  apply trace_length_div_two_pos h_card
end

theorem bad2_bound {inp : input_data F} (pd : public_data F)
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
    (c19 c20 : column F) :
  (bad2 pd h_card c19 c20).card ≤ inp.trace_length / 2 :=
begin
  transitivity,
  apply card_bad_set_2_le,
  rw nat.sub_add_cancel,
  apply trace_length_div_two_pos h_card
end

theorem bad3_bound {inp : input_data F}
    (h_card : 8 * fintype.card { x // option.is_some (inp.m_star x) } + 2 ≤ inp.trace_length)
    (c0 c2 : column F) :
  (bad3 inp c0 c2).card ≤ inp.trace_length :=
begin
  transitivity,
  apply card_bad_set_3_le,
  rw nat.sub_add_cancel,
  exact lt_of_lt_of_le (nat.zero_lt_succ _) h_card
end